<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Cookbook – Cool things to do with it &mdash; Biopython 1.84.dev0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../_static/biopython.css?v=d1305275" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js?v=5d32c60e"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../_static/documentation_options.js?v=49cfa8a4"></script>
        <script src="../_static/doctools.js?v=888ff710"></script>
        <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="The Biopython testing framework" href="chapter_testing.html" />
    <link rel="prev" title="Bio.phenotype: analyze phenotypic data" href="chapter_phenotype.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #10100F" >

          
          
          <a href="../index.html">
            
              <img src="../_static/biopython_logo.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Table of contents</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Biopython Tutorial &amp; Cookbook</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="chapter_introduction.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="chapter_quick_start.html">Quick Start – What can you do with Biopython?</a></li>
<li class="toctree-l2"><a class="reference internal" href="chapter_seq_objects.html">Sequence objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="chapter_seq_annot.html">Sequence annotation objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="chapter_seqio.html">Sequence Input/Output</a></li>
<li class="toctree-l2"><a class="reference internal" href="chapter_align.html">Sequence alignments</a></li>
<li class="toctree-l2"><a class="reference internal" href="chapter_pairwise.html">Pairwise sequence alignment</a></li>
<li class="toctree-l2"><a class="reference internal" href="chapter_msa.html">Multiple Sequence Alignment objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="chapter_pairwise2.html">Pairwise alignments using pairwise2</a></li>
<li class="toctree-l2"><a class="reference internal" href="chapter_blast.html">BLAST (new)</a></li>
<li class="toctree-l2"><a class="reference internal" href="chapter_blast.html#blast-old">BLAST (old)</a></li>
<li class="toctree-l2"><a class="reference internal" href="chapter_searchio.html">BLAST and other sequence search tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="chapter_entrez.html">Accessing NCBI’s Entrez databases</a></li>
<li class="toctree-l2"><a class="reference internal" href="chapter_uniprot.html">Swiss-Prot and ExPASy</a></li>
<li class="toctree-l2"><a class="reference internal" href="chapter_pdb.html">Going 3D: The PDB module</a></li>
<li class="toctree-l2"><a class="reference internal" href="chapter_popgen.html">Bio.PopGen: Population genetics</a></li>
<li class="toctree-l2"><a class="reference internal" href="chapter_phylo.html">Phylogenetics with Bio.Phylo</a></li>
<li class="toctree-l2"><a class="reference internal" href="chapter_motifs.html">Sequence motif analysis using Bio.motifs</a></li>
<li class="toctree-l2"><a class="reference internal" href="chapter_cluster.html">Cluster analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="chapter_graphics.html">Graphics including GenomeDiagram</a></li>
<li class="toctree-l2"><a class="reference internal" href="chapter_kegg.html">KEGG</a></li>
<li class="toctree-l2"><a class="reference internal" href="chapter_phenotype.html">Bio.phenotype: analyze phenotypic data</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Cookbook – Cool things to do with it</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#working-with-sequence-files">Working with sequence files</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#filtering-a-sequence-file">Filtering a sequence file</a></li>
<li class="toctree-l4"><a class="reference internal" href="#producing-randomized-genomes">Producing randomized genomes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#translating-a-fasta-file-of-cds-entries">Translating a FASTA file of CDS entries</a></li>
<li class="toctree-l4"><a class="reference internal" href="#making-the-sequences-in-a-fasta-file-upper-case">Making the sequences in a FASTA file upper case</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sorting-a-sequence-file">Sorting a sequence file</a></li>
<li class="toctree-l4"><a class="reference internal" href="#simple-quality-filtering-for-fastq-files">Simple quality filtering for FASTQ files</a></li>
<li class="toctree-l4"><a class="reference internal" href="#trimming-off-primer-sequences">Trimming off primer sequences</a></li>
<li class="toctree-l4"><a class="reference internal" href="#trimming-off-adaptor-sequences">Trimming off adaptor sequences</a></li>
<li class="toctree-l4"><a class="reference internal" href="#converting-fastq-files">Converting FASTQ files</a></li>
<li class="toctree-l4"><a class="reference internal" href="#converting-fasta-and-qual-files-into-fastq-files">Converting FASTA and QUAL files into FASTQ files</a></li>
<li class="toctree-l4"><a class="reference internal" href="#indexing-a-fastq-file">Indexing a FASTQ file</a></li>
<li class="toctree-l4"><a class="reference internal" href="#converting-sff-files">Converting SFF files</a></li>
<li class="toctree-l4"><a class="reference internal" href="#identifying-open-reading-frames">Identifying open reading frames</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#sequence-parsing-plus-simple-plots">Sequence parsing plus simple plots</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#histogram-of-sequence-lengths">Histogram of sequence lengths</a></li>
<li class="toctree-l4"><a class="reference internal" href="#plot-of-sequence-gc">Plot of sequence GC%</a></li>
<li class="toctree-l4"><a class="reference internal" href="#nucleotide-dot-plots">Nucleotide dot plots</a></li>
<li class="toctree-l4"><a class="reference internal" href="#plotting-the-quality-scores-of-sequencing-read-data">Plotting the quality scores of sequencing read data</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#biosql-storing-sequences-in-a-relational-database">BioSQL – storing sequences in a relational database</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="chapter_testing.html">The Biopython testing framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="chapter_contributing.html">Where to go from here – contributing to Biopython</a></li>
<li class="toctree-l2"><a class="reference internal" href="chapter_appendix.html">Appendix: Useful stuff about Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="chapter_bibliography.html">Bibliography</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../api/index.html">API documentation</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #10100F" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Biopython</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Biopython Tutorial &amp; Cookbook</a></li>
      <li class="breadcrumb-item active">Cookbook – Cool things to do with it</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/biopython/biopython/blob/master/Doc/Tutorial/chapter_cookbook.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul><div class="rst-breadcrumbs-buttons" role="navigation" aria-label="Sequential page navigation">
        <a href="chapter_phenotype.html" class="btn btn-neutral float-left" title="Bio.phenotype: analyze phenotypic data" accesskey="p"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="chapter_testing.html" class="btn btn-neutral float-right" title="The Biopython testing framework" accesskey="n">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
  </div>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="cookbook-cool-things-to-do-with-it">
<span id="chapter-cookbook"></span><h1>Cookbook – Cool things to do with it<a class="headerlink" href="#cookbook-cool-things-to-do-with-it" title="Link to this heading"></a></h1>
<p>Biopython now has two collections of “cookbook” examples – this chapter
(which has been included in this tutorial for many years and has
gradually grown), and <a class="reference external" href="http://biopython.org/wiki/Category:Cookbook">http://biopython.org/wiki/Category:Cookbook</a> which
is a user contributed collection on our wiki.</p>
<p>We’re trying to encourage Biopython users to contribute their own
examples to the wiki. In addition to helping the community, one direct
benefit of sharing an example like this is that you could also get some
feedback on the code from other Biopython users and developers - which
could help you improve all your Python code.</p>
<p>In the long term, we may end up moving all of the examples in this
chapter to the wiki, or elsewhere within the tutorial.</p>
<section id="working-with-sequence-files">
<span id="sec-cookbook-sequences"></span><h2>Working with sequence files<a class="headerlink" href="#working-with-sequence-files" title="Link to this heading"></a></h2>
<p>This section shows some more examples of sequence input/output, using
the <code class="docutils literal notranslate"><span class="pre">Bio.SeqIO</span></code> module described in
Chapter <a class="reference internal" href="chapter_seqio.html#chapter-seqio"><span class="std std-ref">Sequence Input/Output</span></a>.</p>
<section id="filtering-a-sequence-file">
<h3>Filtering a sequence file<a class="headerlink" href="#filtering-a-sequence-file" title="Link to this heading"></a></h3>
<p>Often you’ll have a large file with many sequences in it (e.g. FASTA
file or genes, or a FASTQ or SFF file of reads), a separate shorter list
of the IDs for a subset of sequences of interest, and want to make a new
sequence file for this subset.</p>
<p>Let’s say the list of IDs is in a simple text file, as the first word on
each line. This could be a tabular file where the first column is the
ID. Try something like this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">Bio</span> <span class="kn">import</span> <span class="n">SeqIO</span>

<span class="n">input_file</span> <span class="o">=</span> <span class="s2">&quot;big_file.sff&quot;</span>
<span class="n">id_file</span> <span class="o">=</span> <span class="s2">&quot;short_list.txt&quot;</span>
<span class="n">output_file</span> <span class="o">=</span> <span class="s2">&quot;short_list.sff&quot;</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">id_file</span><span class="p">)</span> <span class="k">as</span> <span class="n">id_handle</span><span class="p">:</span>
    <span class="n">wanted</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">id_handle</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Found </span><span class="si">%i</span><span class="s2"> unique identifiers in </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">wanted</span><span class="p">),</span> <span class="n">id_file</span><span class="p">))</span>

<span class="n">records</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">SeqIO</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">input_file</span><span class="p">,</span> <span class="s2">&quot;sff&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">id</span> <span class="ow">in</span> <span class="n">wanted</span><span class="p">)</span>
<span class="n">count</span> <span class="o">=</span> <span class="n">SeqIO</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">records</span><span class="p">,</span> <span class="n">output_file</span><span class="p">,</span> <span class="s2">&quot;sff&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Saved </span><span class="si">%i</span><span class="s2"> records from </span><span class="si">%s</span><span class="s2"> to </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="n">input_file</span><span class="p">,</span> <span class="n">output_file</span><span class="p">))</span>
<span class="k">if</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">wanted</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning </span><span class="si">%i</span><span class="s2"> IDs not found in </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">wanted</span><span class="p">)</span> <span class="o">-</span> <span class="n">count</span><span class="p">,</span> <span class="n">input_file</span><span class="p">))</span>
</pre></div>
</div>
<p>Note that we use a Python <code class="docutils literal notranslate"><span class="pre">set</span></code> rather than a <code class="docutils literal notranslate"><span class="pre">list</span></code>, this makes
testing membership faster.</p>
<p>As discussed in
Section <a class="reference internal" href="chapter_seqio.html#sec-low-level-fasta-fastq"><span class="std std-ref">Low level FASTA and FASTQ parsers</span></a>,
for a large FASTA or FASTQ file for speed you would be better off not
using the high-level <code class="docutils literal notranslate"><span class="pre">SeqIO</span></code> interface, but working directly with
strings. This next example shows how to do this with FASTQ files – it is
more complicated:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">Bio.SeqIO.QualityIO</span> <span class="kn">import</span> <span class="n">FastqGeneralIterator</span>

<span class="n">input_file</span> <span class="o">=</span> <span class="s2">&quot;big_file.fastq&quot;</span>
<span class="n">id_file</span> <span class="o">=</span> <span class="s2">&quot;short_list.txt&quot;</span>
<span class="n">output_file</span> <span class="o">=</span> <span class="s2">&quot;short_list.fastq&quot;</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">id_file</span><span class="p">)</span> <span class="k">as</span> <span class="n">id_handle</span><span class="p">:</span>
    <span class="c1"># Taking first word on each line as an identifier</span>
    <span class="n">wanted</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">id_handle</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Found </span><span class="si">%i</span><span class="s2"> unique identifiers in </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">wanted</span><span class="p">),</span> <span class="n">id_file</span><span class="p">))</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">input_file</span><span class="p">)</span> <span class="k">as</span> <span class="n">in_handle</span><span class="p">:</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">output_file</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">out_handle</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">title</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="n">qual</span> <span class="ow">in</span> <span class="n">FastqGeneralIterator</span><span class="p">(</span><span class="n">in_handle</span><span class="p">):</span>
            <span class="c1"># The ID is the first word in the title line (after the @ sign):</span>
            <span class="k">if</span> <span class="n">title</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">wanted</span><span class="p">:</span>
                <span class="c1"># This produces a standard 4-line FASTQ entry:</span>
                <span class="n">out_handle</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;@</span><span class="si">%s</span><span class="se">\n</span><span class="si">%s</span><span class="se">\n</span><span class="s2">+</span><span class="se">\n</span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="n">qual</span><span class="p">))</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Saved </span><span class="si">%i</span><span class="s2"> records from </span><span class="si">%s</span><span class="s2"> to </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="n">input_file</span><span class="p">,</span> <span class="n">output_file</span><span class="p">))</span>
<span class="k">if</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">wanted</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning </span><span class="si">%i</span><span class="s2"> IDs not found in </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">wanted</span><span class="p">)</span> <span class="o">-</span> <span class="n">count</span><span class="p">,</span> <span class="n">input_file</span><span class="p">))</span>
</pre></div>
</div>
</section>
<section id="producing-randomized-genomes">
<h3>Producing randomized genomes<a class="headerlink" href="#producing-randomized-genomes" title="Link to this heading"></a></h3>
<p>Let’s suppose you are looking at genome sequence, hunting for some
sequence feature – maybe extreme local GC% bias, or possible restriction
digest sites. Once you’ve got your Python code working on the real
genome it may be sensible to try running the same search on randomized
versions of the same genome for statistical analysis (after all, any
“features” you’ve found could just be there just by chance).</p>
<p>For this discussion, we’ll use the GenBank file for the pPCP1 plasmid
from <em>Yersinia pestis biovar Microtus</em>. The file is included with the
Biopython unit tests under the GenBank folder, or you can get it from
our website,
<code class="docutils literal notranslate"><span class="pre">`NC_005816.gb</span></code> &lt;<a class="reference external" href="https://raw.githubusercontent.com/biopython/biopython/master/Tests/GenBank/NC_005816.gb">https://raw.githubusercontent.com/biopython/biopython/master/Tests/GenBank/NC_005816.gb</a>&gt;`__.
This file contains one and only one record, so we can read it in as a
<code class="docutils literal notranslate"><span class="pre">SeqRecord</span></code> using the <code class="docutils literal notranslate"><span class="pre">Bio.SeqIO.read()</span></code> function:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio</span> <span class="kn">import</span> <span class="n">SeqIO</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">original_rec</span> <span class="o">=</span> <span class="n">SeqIO</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s2">&quot;NC_005816.gb&quot;</span><span class="p">,</span> <span class="s2">&quot;genbank&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>So, how can we generate a shuffled versions of the original sequence? I
would use the built in Python <code class="docutils literal notranslate"><span class="pre">random</span></code> module for this, in particular
the function <code class="docutils literal notranslate"><span class="pre">random.shuffle</span></code> – but this works on a Python list. Our
sequence is a <code class="docutils literal notranslate"><span class="pre">Seq</span></code> object, so in order to shuffle it we need to turn
it into a list:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">random</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nuc_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">original_rec</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">nuc_list</span><span class="p">)</span>  <span class="c1"># acts in situ!</span>
</pre></div>
</div>
<p>Now, in order to use <code class="docutils literal notranslate"><span class="pre">Bio.SeqIO</span></code> to output the shuffled sequence, we
need to construct a new <code class="docutils literal notranslate"><span class="pre">SeqRecord</span></code> with a new <code class="docutils literal notranslate"><span class="pre">Seq</span></code> object using
this shuffled list. In order to do this, we need to turn the list of
nucleotides (single letter strings) into a long string – the standard
Python way to do this is with the string object’s join method.</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.Seq</span> <span class="kn">import</span> <span class="n">Seq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.SeqRecord</span> <span class="kn">import</span> <span class="n">SeqRecord</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">shuffled_rec</span> <span class="o">=</span> <span class="n">SeqRecord</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">Seq</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">nuc_list</span><span class="p">)),</span> <span class="nb">id</span><span class="o">=</span><span class="s2">&quot;Shuffled&quot;</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Based on </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">original_rec</span><span class="o">.</span><span class="n">id</span>
<span class="gp">... </span><span class="p">)</span>
</pre></div>
</div>
<p>Let’s put all these pieces together to make a complete Python script
which generates a single FASTA file containing 30 randomly shuffled
versions of the original sequence.</p>
<p>This first version just uses a big for loop and writes out the records
one by one (using the <code class="docutils literal notranslate"><span class="pre">SeqRecord</span></code>’s format method described in
Section <a class="reference internal" href="chapter_seqio.html#sec-bio-seqio-and-stringio"><span class="std std-ref">Getting your SeqRecord objects as formatted strings</span></a>):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">random</span>
<span class="kn">from</span> <span class="nn">Bio.Seq</span> <span class="kn">import</span> <span class="n">Seq</span>
<span class="kn">from</span> <span class="nn">Bio.SeqRecord</span> <span class="kn">import</span> <span class="n">SeqRecord</span>
<span class="kn">from</span> <span class="nn">Bio</span> <span class="kn">import</span> <span class="n">SeqIO</span>

<span class="n">original_rec</span> <span class="o">=</span> <span class="n">SeqIO</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s2">&quot;NC_005816.gb&quot;</span><span class="p">,</span> <span class="s2">&quot;genbank&quot;</span><span class="p">)</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;shuffled.fasta&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">output_handle</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">30</span><span class="p">):</span>
        <span class="n">nuc_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">original_rec</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span>
        <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">nuc_list</span><span class="p">)</span>
        <span class="n">shuffled_rec</span> <span class="o">=</span> <span class="n">SeqRecord</span><span class="p">(</span>
            <span class="n">Seq</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">nuc_list</span><span class="p">)),</span>
            <span class="nb">id</span><span class="o">=</span><span class="s2">&quot;Shuffled</span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
            <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Based on </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">original_rec</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">output_handle</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">shuffled_rec</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;fasta&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p>Personally I prefer the following version using a function to shuffle
the record and a generator expression instead of the for loop:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">random</span>
<span class="kn">from</span> <span class="nn">Bio.Seq</span> <span class="kn">import</span> <span class="n">Seq</span>
<span class="kn">from</span> <span class="nn">Bio.SeqRecord</span> <span class="kn">import</span> <span class="n">SeqRecord</span>
<span class="kn">from</span> <span class="nn">Bio</span> <span class="kn">import</span> <span class="n">SeqIO</span>


<span class="k">def</span> <span class="nf">make_shuffle_record</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="n">new_id</span><span class="p">):</span>
    <span class="n">nuc_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">record</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span>
    <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">nuc_list</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">SeqRecord</span><span class="p">(</span>
        <span class="n">Seq</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">nuc_list</span><span class="p">)),</span>
        <span class="nb">id</span><span class="o">=</span><span class="n">new_id</span><span class="p">,</span>
        <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Based on </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">original_rec</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
    <span class="p">)</span>


<span class="n">original_rec</span> <span class="o">=</span> <span class="n">SeqIO</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s2">&quot;NC_005816.gb&quot;</span><span class="p">,</span> <span class="s2">&quot;genbank&quot;</span><span class="p">)</span>
<span class="n">shuffled_recs</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">make_shuffle_record</span><span class="p">(</span><span class="n">original_rec</span><span class="p">,</span> <span class="s2">&quot;Shuffled</span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>
<span class="p">)</span>

<span class="n">SeqIO</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">shuffled_recs</span><span class="p">,</span> <span class="s2">&quot;shuffled.fasta&quot;</span><span class="p">,</span> <span class="s2">&quot;fasta&quot;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="translating-a-fasta-file-of-cds-entries">
<span id="sec-seqio-translate"></span><h3>Translating a FASTA file of CDS entries<a class="headerlink" href="#translating-a-fasta-file-of-cds-entries" title="Link to this heading"></a></h3>
<p>Suppose you’ve got an input file of CDS entries for some organism, and
you want to generate a new FASTA file containing their protein
sequences. i.e. Take each nucleotide sequence from the original file,
and translate it. Back in
Section <a class="reference internal" href="chapter_seq_objects.html#sec-translation"><span class="std std-ref">Translation</span></a> we saw how to use the
<code class="docutils literal notranslate"><span class="pre">Seq</span></code> object’s <code class="docutils literal notranslate"><span class="pre">translate</span> <span class="pre">method</span></code>, and the optional <code class="docutils literal notranslate"><span class="pre">cds</span></code> argument
which enables correct translation of alternative start codons.</p>
<p>We can combine this with <code class="docutils literal notranslate"><span class="pre">Bio.SeqIO</span></code> as shown in the reverse
complement example in
Section <a class="reference internal" href="chapter_seqio.html#sec-seqio-reverse-complement"><span class="std std-ref">Converting a file of sequences to their reverse complements</span></a>.
The key point is that for each nucleotide <code class="docutils literal notranslate"><span class="pre">SeqRecord</span></code>, we need to
create a protein <code class="docutils literal notranslate"><span class="pre">SeqRecord</span></code> - and take care of naming it.</p>
<p>You can write you own function to do this, choosing suitable protein
identifiers for your sequences, and the appropriate genetic code. In
this example we just use the default table and add a prefix to the
identifier:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">Bio.SeqRecord</span> <span class="kn">import</span> <span class="n">SeqRecord</span>


<span class="k">def</span> <span class="nf">make_protein_record</span><span class="p">(</span><span class="n">nuc_record</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns a new SeqRecord with the translated sequence (default table).&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">SeqRecord</span><span class="p">(</span>
        <span class="n">seq</span><span class="o">=</span><span class="n">nuc_record</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">cds</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
        <span class="nb">id</span><span class="o">=</span><span class="s2">&quot;trans_&quot;</span> <span class="o">+</span> <span class="n">nuc_record</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
        <span class="n">description</span><span class="o">=</span><span class="s2">&quot;translation of CDS, using default table&quot;</span><span class="p">,</span>
    <span class="p">)</span>
</pre></div>
</div>
<p>We can then use this function to turn the input nucleotide records into
protein records ready for output. An elegant way and memory efficient
way to do this is with a generator expression:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">Bio</span> <span class="kn">import</span> <span class="n">SeqIO</span>

<span class="n">proteins</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">make_protein_record</span><span class="p">(</span><span class="n">nuc_rec</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">nuc_rec</span> <span class="ow">in</span> <span class="n">SeqIO</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;coding_sequences.fasta&quot;</span><span class="p">,</span> <span class="s2">&quot;fasta&quot;</span><span class="p">)</span>
<span class="p">)</span>
<span class="n">SeqIO</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">proteins</span><span class="p">,</span> <span class="s2">&quot;translations.fasta&quot;</span><span class="p">,</span> <span class="s2">&quot;fasta&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>This should work on any FASTA file of complete coding sequences. If you
are working on partial coding sequences, you may prefer to use
<code class="docutils literal notranslate"><span class="pre">nuc_record.seq.translate(to_stop=True)</span></code> in the example above, as this
wouldn’t check for a valid start codon etc.</p>
</section>
<section id="making-the-sequences-in-a-fasta-file-upper-case">
<h3>Making the sequences in a FASTA file upper case<a class="headerlink" href="#making-the-sequences-in-a-fasta-file-upper-case" title="Link to this heading"></a></h3>
<p>Often you’ll get data from collaborators as FASTA files, and sometimes
the sequences can be in a mixture of upper and lower case. In some cases
this is deliberate (e.g. lower case for poor quality regions), but
usually it is not important. You may want to edit the file to make
everything consistent (e.g. all upper case), and you can do this easily
using the <code class="docutils literal notranslate"><span class="pre">upper()</span></code> method of the <code class="docutils literal notranslate"><span class="pre">SeqRecord</span></code> object (added in
Biopython 1.55):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">Bio</span> <span class="kn">import</span> <span class="n">SeqIO</span>

<span class="n">records</span> <span class="o">=</span> <span class="p">(</span><span class="n">rec</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="k">for</span> <span class="n">rec</span> <span class="ow">in</span> <span class="n">SeqIO</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;mixed.fas&quot;</span><span class="p">,</span> <span class="s2">&quot;fasta&quot;</span><span class="p">))</span>
<span class="n">count</span> <span class="o">=</span> <span class="n">SeqIO</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">records</span><span class="p">,</span> <span class="s2">&quot;upper.fas&quot;</span><span class="p">,</span> <span class="s2">&quot;fasta&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Converted </span><span class="si">%i</span><span class="s2"> records to upper case&quot;</span> <span class="o">%</span> <span class="n">count</span><span class="p">)</span>
</pre></div>
</div>
<p>How does this work? The first line is just importing the <code class="docutils literal notranslate"><span class="pre">Bio.SeqIO</span></code>
module. The second line is the interesting bit – this is a Python
generator expression which gives an upper case version of each record
parsed from the input file (<code class="docutils literal notranslate"><span class="pre">mixed.fas</span></code>). In the third line we give
this generator expression to the <code class="docutils literal notranslate"><span class="pre">Bio.SeqIO.write()</span></code> function and it
saves the new upper cases records to our output file (<code class="docutils literal notranslate"><span class="pre">upper.fas</span></code>).</p>
<p>The reason we use a generator expression (rather than a list or list
comprehension) is this means only one record is kept in memory at a
time. This can be really important if you are dealing with large files
with millions of entries.</p>
</section>
<section id="sorting-a-sequence-file">
<span id="sec-seqio-sort"></span><h3>Sorting a sequence file<a class="headerlink" href="#sorting-a-sequence-file" title="Link to this heading"></a></h3>
<p>Suppose you wanted to sort a sequence file by length (e.g. a set of
contigs from an assembly), and you are working with a file format like
FASTA or FASTQ which <code class="docutils literal notranslate"><span class="pre">Bio.SeqIO</span></code> can read, write (and index).</p>
<p>If the file is small enough, you can load it all into memory at once as
a list of <code class="docutils literal notranslate"><span class="pre">SeqRecord</span></code> objects, sort the list, and save it:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">Bio</span> <span class="kn">import</span> <span class="n">SeqIO</span>

<span class="n">records</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">SeqIO</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;ls_orchid.fasta&quot;</span><span class="p">,</span> <span class="s2">&quot;fasta&quot;</span><span class="p">))</span>
<span class="n">records</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">r</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
<span class="n">SeqIO</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">records</span><span class="p">,</span> <span class="s2">&quot;sorted_orchids.fasta&quot;</span><span class="p">,</span> <span class="s2">&quot;fasta&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>The only clever bit is specifying a comparison method for how to sort
the records (here we sort them by length). If you wanted the longest
records first, you could flip the comparison or use the reverse
argument:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">Bio</span> <span class="kn">import</span> <span class="n">SeqIO</span>

<span class="n">records</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">SeqIO</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;ls_orchid.fasta&quot;</span><span class="p">,</span> <span class="s2">&quot;fasta&quot;</span><span class="p">))</span>
<span class="n">records</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">r</span><span class="p">:</span> <span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
<span class="n">SeqIO</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">records</span><span class="p">,</span> <span class="s2">&quot;sorted_orchids.fasta&quot;</span><span class="p">,</span> <span class="s2">&quot;fasta&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Now that’s pretty straight forward - but what happens if you have a very
large file and you can’t load it all into memory like this? For example,
you might have some next-generation sequencing reads to sort by length.
This can be solved using the <code class="docutils literal notranslate"><span class="pre">Bio.SeqIO.index()</span></code> function.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">Bio</span> <span class="kn">import</span> <span class="n">SeqIO</span>

<span class="c1"># Get the lengths and ids, and sort on length</span>
<span class="n">len_and_ids</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
    <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rec</span><span class="p">),</span> <span class="n">rec</span><span class="o">.</span><span class="n">id</span><span class="p">)</span> <span class="k">for</span> <span class="n">rec</span> <span class="ow">in</span> <span class="n">SeqIO</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;ls_orchid.fasta&quot;</span><span class="p">,</span> <span class="s2">&quot;fasta&quot;</span><span class="p">)</span>
<span class="p">)</span>
<span class="n">ids</span> <span class="o">=</span> <span class="nb">reversed</span><span class="p">([</span><span class="nb">id</span> <span class="k">for</span> <span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="nb">id</span><span class="p">)</span> <span class="ow">in</span> <span class="n">len_and_ids</span><span class="p">])</span>
<span class="k">del</span> <span class="n">len_and_ids</span>  <span class="c1"># free this memory</span>
<span class="n">record_index</span> <span class="o">=</span> <span class="n">SeqIO</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;ls_orchid.fasta&quot;</span><span class="p">,</span> <span class="s2">&quot;fasta&quot;</span><span class="p">)</span>
<span class="n">records</span> <span class="o">=</span> <span class="p">(</span><span class="n">record_index</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span> <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">ids</span><span class="p">)</span>
<span class="n">SeqIO</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">records</span><span class="p">,</span> <span class="s2">&quot;sorted.fasta&quot;</span><span class="p">,</span> <span class="s2">&quot;fasta&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>First we scan through the file once using <code class="docutils literal notranslate"><span class="pre">Bio.SeqIO.parse()</span></code>,
recording the record identifiers and their lengths in a list of tuples.
We then sort this list to get them in length order, and discard the
lengths. Using this sorted list of identifiers <code class="docutils literal notranslate"><span class="pre">Bio.SeqIO.index()</span></code>
allows us to retrieve the records one by one, and we pass them to
<code class="docutils literal notranslate"><span class="pre">Bio.SeqIO.write()</span></code> for output.</p>
<p>These examples all use <code class="docutils literal notranslate"><span class="pre">Bio.SeqIO</span></code> to parse the records into
<code class="docutils literal notranslate"><span class="pre">SeqRecord</span></code> objects which are output using <code class="docutils literal notranslate"><span class="pre">Bio.SeqIO.write()</span></code>. What
if you want to sort a file format which <code class="docutils literal notranslate"><span class="pre">Bio.SeqIO.write()</span></code> doesn’t
support, like the plain text SwissProt format? Here is an alternative
solution using the <code class="docutils literal notranslate"><span class="pre">get_raw()</span></code> method added to <code class="docutils literal notranslate"><span class="pre">Bio.SeqIO.index()</span></code>
in Biopython 1.54 (see
Section <a class="reference internal" href="chapter_seqio.html#sec-seqio-index-getraw"><span class="std std-ref">Getting the raw data for a record</span></a>).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">Bio</span> <span class="kn">import</span> <span class="n">SeqIO</span>

<span class="c1"># Get the lengths and ids, and sort on length</span>
<span class="n">len_and_ids</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
    <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rec</span><span class="p">),</span> <span class="n">rec</span><span class="o">.</span><span class="n">id</span><span class="p">)</span> <span class="k">for</span> <span class="n">rec</span> <span class="ow">in</span> <span class="n">SeqIO</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;ls_orchid.fasta&quot;</span><span class="p">,</span> <span class="s2">&quot;fasta&quot;</span><span class="p">)</span>
<span class="p">)</span>
<span class="n">ids</span> <span class="o">=</span> <span class="nb">reversed</span><span class="p">([</span><span class="nb">id</span> <span class="k">for</span> <span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="nb">id</span><span class="p">)</span> <span class="ow">in</span> <span class="n">len_and_ids</span><span class="p">])</span>
<span class="k">del</span> <span class="n">len_and_ids</span>  <span class="c1"># free this memory</span>

<span class="n">record_index</span> <span class="o">=</span> <span class="n">SeqIO</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;ls_orchid.fasta&quot;</span><span class="p">,</span> <span class="s2">&quot;fasta&quot;</span><span class="p">)</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;sorted.fasta&quot;</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">out_handle</span><span class="p">:</span>
    <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">ids</span><span class="p">:</span>
        <span class="n">out_handle</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">record_index</span><span class="o">.</span><span class="n">get_raw</span><span class="p">(</span><span class="nb">id</span><span class="p">))</span>
</pre></div>
</div>
<p>Note with Python 3 onwards, we have to open the file for writing in
binary mode because the <code class="docutils literal notranslate"><span class="pre">get_raw()</span></code> method returns <code class="docutils literal notranslate"><span class="pre">bytes</span></code> objects.</p>
<p>As a bonus, because it doesn’t parse the data into <code class="docutils literal notranslate"><span class="pre">SeqRecord</span></code> objects
a second time it should be faster. If you only want to use this with
FASTA format, we can speed this up one step further by using the
low-level FASTA parser to get the record identifiers and lengths:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">Bio.SeqIO.FastaIO</span> <span class="kn">import</span> <span class="n">SimpleFastaParser</span>
<span class="kn">from</span> <span class="nn">Bio</span> <span class="kn">import</span> <span class="n">SeqIO</span>

<span class="c1"># Get the lengths and ids, and sort on length</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;ls_orchid.fasta&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">in_handle</span><span class="p">:</span>
    <span class="n">len_and_ids</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
        <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">),</span> <span class="n">title</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">title</span><span class="p">,</span> <span class="n">seq</span> <span class="ow">in</span> <span class="n">SimpleFastaParser</span><span class="p">(</span><span class="n">in_handle</span><span class="p">)</span>
    <span class="p">)</span>
<span class="n">ids</span> <span class="o">=</span> <span class="nb">reversed</span><span class="p">([</span><span class="nb">id</span> <span class="k">for</span> <span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="nb">id</span><span class="p">)</span> <span class="ow">in</span> <span class="n">len_and_ids</span><span class="p">])</span>
<span class="k">del</span> <span class="n">len_and_ids</span>  <span class="c1"># free this memory</span>

<span class="n">record_index</span> <span class="o">=</span> <span class="n">SeqIO</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;ls_orchid.fasta&quot;</span><span class="p">,</span> <span class="s2">&quot;fasta&quot;</span><span class="p">)</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;sorted.fasta&quot;</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">out_handle</span><span class="p">:</span>
    <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">ids</span><span class="p">:</span>
        <span class="n">out_handle</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">record_index</span><span class="o">.</span><span class="n">get_raw</span><span class="p">(</span><span class="nb">id</span><span class="p">))</span>
</pre></div>
</div>
</section>
<section id="simple-quality-filtering-for-fastq-files">
<span id="sec-fastq-filtering-example"></span><h3>Simple quality filtering for FASTQ files<a class="headerlink" href="#simple-quality-filtering-for-fastq-files" title="Link to this heading"></a></h3>
<p>The FASTQ file format was introduced at Sanger and is now widely used
for holding nucleotide sequencing reads together with their quality
scores. FASTQ files (and the related QUAL files) are an excellent
example of per-letter-annotation, because for each nucleotide in the
sequence there is an associated quality score. Any per-letter-annotation
is held in a <code class="docutils literal notranslate"><span class="pre">SeqRecord</span></code> in the <code class="docutils literal notranslate"><span class="pre">letter_annotations</span></code> dictionary as a
list, tuple or string (with the same number of elements as the sequence
length).</p>
<p>One common task is taking a large set of sequencing reads and filtering
them (or cropping them) based on their quality scores. The following
example is very simplistic, but should illustrate the basics of working
with quality data in a <code class="docutils literal notranslate"><span class="pre">SeqRecord</span></code> object. All we are going to do here
is read in a file of FASTQ data, and filter it to pick out only those
records whose PHRED quality scores are all above some threshold (here
20).</p>
<p>For this example we’ll use some real data downloaded from the ENA
sequence read archive,
<a class="reference external" href="ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR020/SRR020192/SRR020192.fastq.gz">ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR020/SRR020192/SRR020192.fastq.gz</a>
(2MB) which unzips to a 19MB file <code class="docutils literal notranslate"><span class="pre">SRR020192.fastq</span></code>. This is some
Roche 454 GS FLX single end data from virus infected California sea
lions (see <a class="reference external" href="https://www.ebi.ac.uk/ena/data/view/SRS004476">https://www.ebi.ac.uk/ena/data/view/SRS004476</a> for details).</p>
<p>First, let’s count the reads:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">Bio</span> <span class="kn">import</span> <span class="n">SeqIO</span>

<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">rec</span> <span class="ow">in</span> <span class="n">SeqIO</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;SRR020192.fastq&quot;</span><span class="p">,</span> <span class="s2">&quot;fastq&quot;</span><span class="p">):</span>
    <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%i</span><span class="s2"> reads&quot;</span> <span class="o">%</span> <span class="n">count</span><span class="p">)</span>
</pre></div>
</div>
<p>Now let’s do a simple filtering for a minimum PHRED quality of 20:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">Bio</span> <span class="kn">import</span> <span class="n">SeqIO</span>

<span class="n">good_reads</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">rec</span>
    <span class="k">for</span> <span class="n">rec</span> <span class="ow">in</span> <span class="n">SeqIO</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;SRR020192.fastq&quot;</span><span class="p">,</span> <span class="s2">&quot;fastq&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">rec</span><span class="o">.</span><span class="n">letter_annotations</span><span class="p">[</span><span class="s2">&quot;phred_quality&quot;</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="mi">20</span>
<span class="p">)</span>
<span class="n">count</span> <span class="o">=</span> <span class="n">SeqIO</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">good_reads</span><span class="p">,</span> <span class="s2">&quot;good_quality.fastq&quot;</span><span class="p">,</span> <span class="s2">&quot;fastq&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Saved </span><span class="si">%i</span><span class="s2"> reads&quot;</span> <span class="o">%</span> <span class="n">count</span><span class="p">)</span>
</pre></div>
</div>
<p>This pulled out only <span class="math notranslate nohighlight">\(14580\)</span> reads out of the <span class="math notranslate nohighlight">\(41892\)</span>
present. A more sensible thing to do would be to quality trim the reads,
but this is intended as an example only.</p>
<p>FASTQ files can contain millions of entries, so it is best to avoid
loading them all into memory at once. This example uses a generator
expression, which means only one <code class="docutils literal notranslate"><span class="pre">SeqRecord</span></code> is created at a time -
avoiding any memory limitations.</p>
<p>Note that it would be faster to use the low-level
<code class="docutils literal notranslate"><span class="pre">FastqGeneralIterator</span></code> parser here (see
Section <a class="reference internal" href="chapter_seqio.html#sec-low-level-fasta-fastq"><span class="std std-ref">Low level FASTA and FASTQ parsers</span></a>),
but that does not turn the quality string into integer scores.</p>
</section>
<section id="trimming-off-primer-sequences">
<span id="sec-fastq-slicing-off-primer"></span><h3>Trimming off primer sequences<a class="headerlink" href="#trimming-off-primer-sequences" title="Link to this heading"></a></h3>
<p>For this example we’re going to pretend that <code class="docutils literal notranslate"><span class="pre">GATGACGGTGT</span></code> is a 5’
primer sequence we want to look for in some FASTQ formatted read data.
As in the example above, we’ll use the <code class="docutils literal notranslate"><span class="pre">SRR020192.fastq</span></code> file
downloaded from the ENA
(<a class="reference external" href="ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR020/SRR020192/SRR020192.fastq.gz">ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR020/SRR020192/SRR020192.fastq.gz</a>).</p>
<p>By using the main <code class="docutils literal notranslate"><span class="pre">Bio.SeqIO</span></code> interface, the same approach would work
with any other supported file format (e.g. FASTA files). However, for
large FASTQ files it would be faster the low-level
<code class="docutils literal notranslate"><span class="pre">FastqGeneralIterator</span></code> parser here (see the earlier example, and
Section <a class="reference internal" href="chapter_seqio.html#sec-low-level-fasta-fastq"><span class="std std-ref">Low level FASTA and FASTQ parsers</span></a>).</p>
<p>This code uses <code class="docutils literal notranslate"><span class="pre">Bio.SeqIO</span></code> with a generator expression (to avoid
loading all the sequences into memory at once), and the <code class="docutils literal notranslate"><span class="pre">Seq</span></code> object’s
<code class="docutils literal notranslate"><span class="pre">startswith</span></code> method to see if the read starts with the primer
sequence:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">Bio</span> <span class="kn">import</span> <span class="n">SeqIO</span>

<span class="n">primer_reads</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">rec</span>
    <span class="k">for</span> <span class="n">rec</span> <span class="ow">in</span> <span class="n">SeqIO</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;SRR020192.fastq&quot;</span><span class="p">,</span> <span class="s2">&quot;fastq&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rec</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;GATGACGGTGT&quot;</span><span class="p">)</span>
<span class="p">)</span>
<span class="n">count</span> <span class="o">=</span> <span class="n">SeqIO</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">primer_reads</span><span class="p">,</span> <span class="s2">&quot;with_primer.fastq&quot;</span><span class="p">,</span> <span class="s2">&quot;fastq&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Saved </span><span class="si">%i</span><span class="s2"> reads&quot;</span> <span class="o">%</span> <span class="n">count</span><span class="p">)</span>
</pre></div>
</div>
<p>That should find <span class="math notranslate nohighlight">\(13819\)</span> reads from <code class="docutils literal notranslate"><span class="pre">SRR014849.fastq</span></code> and save
them to a new FASTQ file, <code class="docutils literal notranslate"><span class="pre">with_primer.fastq</span></code>.</p>
<p>Now suppose that instead you wanted to make a FASTQ file containing
these reads but with the primer sequence removed? That’s just a small
change as we can slice the <code class="docutils literal notranslate"><span class="pre">SeqRecord</span></code> (see
Section <a class="reference internal" href="chapter_seq_annot.html#sec-seqrecord-slicing"><span class="std std-ref">Slicing a SeqRecord</span></a>) to remove
the first eleven letters (the length of our primer):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">Bio</span> <span class="kn">import</span> <span class="n">SeqIO</span>

<span class="n">trimmed_primer_reads</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">rec</span><span class="p">[</span><span class="mi">11</span><span class="p">:]</span>
    <span class="k">for</span> <span class="n">rec</span> <span class="ow">in</span> <span class="n">SeqIO</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;SRR020192.fastq&quot;</span><span class="p">,</span> <span class="s2">&quot;fastq&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rec</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;GATGACGGTGT&quot;</span><span class="p">)</span>
<span class="p">)</span>
<span class="n">count</span> <span class="o">=</span> <span class="n">SeqIO</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">trimmed_primer_reads</span><span class="p">,</span> <span class="s2">&quot;with_primer_trimmed.fastq&quot;</span><span class="p">,</span> <span class="s2">&quot;fastq&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Saved </span><span class="si">%i</span><span class="s2"> reads&quot;</span> <span class="o">%</span> <span class="n">count</span><span class="p">)</span>
</pre></div>
</div>
<p>Again, that should pull out the <span class="math notranslate nohighlight">\(13819\)</span> reads from
<code class="docutils literal notranslate"><span class="pre">SRR020192.fastq</span></code>, but this time strip off the first ten characters,
and save them to another new FASTQ file, <code class="docutils literal notranslate"><span class="pre">with_primer_trimmed.fastq</span></code>.</p>
<p>Now, suppose you want to create a new FASTQ file where these reads have
their primer removed, but all the other reads are kept as they were? If
we want to still use a generator expression, it is probably clearest to
define our own trim function:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">Bio</span> <span class="kn">import</span> <span class="n">SeqIO</span>


<span class="k">def</span> <span class="nf">trim_primer</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="n">primer</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">record</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">primer</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">record</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">primer</span><span class="p">)</span> <span class="p">:]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">record</span>


<span class="n">trimmed_reads</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">trim_primer</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="s2">&quot;GATGACGGTGT&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">SeqIO</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;SRR020192.fastq&quot;</span><span class="p">,</span> <span class="s2">&quot;fastq&quot;</span><span class="p">)</span>
<span class="p">)</span>
<span class="n">count</span> <span class="o">=</span> <span class="n">SeqIO</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">trimmed_reads</span><span class="p">,</span> <span class="s2">&quot;trimmed.fastq&quot;</span><span class="p">,</span> <span class="s2">&quot;fastq&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Saved </span><span class="si">%i</span><span class="s2"> reads&quot;</span> <span class="o">%</span> <span class="n">count</span><span class="p">)</span>
</pre></div>
</div>
<p>This takes longer, as this time the output file contains all
<span class="math notranslate nohighlight">\(41892\)</span> reads. Again, we’re used a generator expression to avoid
any memory problems. You could alternatively use a generator function
rather than a generator expression.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">Bio</span> <span class="kn">import</span> <span class="n">SeqIO</span>


<span class="k">def</span> <span class="nf">trim_primers</span><span class="p">(</span><span class="n">records</span><span class="p">,</span> <span class="n">primer</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Removes perfect primer sequences at start of reads.</span>

<span class="sd">    This is a generator function, the records argument should</span>
<span class="sd">    be a list or iterator returning SeqRecord objects.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">len_primer</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">primer</span><span class="p">)</span>  <span class="c1"># cache this for later</span>
    <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">records</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">record</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">primer</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">record</span><span class="p">[</span><span class="n">len_primer</span><span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">record</span>


<span class="n">original_reads</span> <span class="o">=</span> <span class="n">SeqIO</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;SRR020192.fastq&quot;</span><span class="p">,</span> <span class="s2">&quot;fastq&quot;</span><span class="p">)</span>
<span class="n">trimmed_reads</span> <span class="o">=</span> <span class="n">trim_primers</span><span class="p">(</span><span class="n">original_reads</span><span class="p">,</span> <span class="s2">&quot;GATGACGGTGT&quot;</span><span class="p">)</span>
<span class="n">count</span> <span class="o">=</span> <span class="n">SeqIO</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">trimmed_reads</span><span class="p">,</span> <span class="s2">&quot;trimmed.fastq&quot;</span><span class="p">,</span> <span class="s2">&quot;fastq&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Saved </span><span class="si">%i</span><span class="s2"> reads&quot;</span> <span class="o">%</span> <span class="n">count</span><span class="p">)</span>
</pre></div>
</div>
<p>This form is more flexible if you want to do something more complicated
where only some of the records are retained – as shown in the next
example.</p>
</section>
<section id="trimming-off-adaptor-sequences">
<span id="sec-fastq-slicing-off-adaptor"></span><h3>Trimming off adaptor sequences<a class="headerlink" href="#trimming-off-adaptor-sequences" title="Link to this heading"></a></h3>
<p>This is essentially a simple extension to the previous example. We are
going to going to pretend <code class="docutils literal notranslate"><span class="pre">GATGACGGTGT</span></code> is an adaptor sequence in some
FASTQ formatted read data, again the <code class="docutils literal notranslate"><span class="pre">SRR020192.fastq</span></code> file from the
NCBI
(<a class="reference external" href="ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR020/SRR020192/SRR020192.fastq.gz">ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR020/SRR020192/SRR020192.fastq.gz</a>).</p>
<p>This time however, we will look for the sequence <em>anywhere</em> in the
reads, not just at the very beginning:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">Bio</span> <span class="kn">import</span> <span class="n">SeqIO</span>


<span class="k">def</span> <span class="nf">trim_adaptors</span><span class="p">(</span><span class="n">records</span><span class="p">,</span> <span class="n">adaptor</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Trims perfect adaptor sequences.</span>

<span class="sd">    This is a generator function, the records argument should</span>
<span class="sd">    be a list or iterator returning SeqRecord objects.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">len_adaptor</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">adaptor</span><span class="p">)</span>  <span class="c1"># cache this for later</span>
    <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">records</span><span class="p">:</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">record</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">adaptor</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="c1"># adaptor not found, so won&#39;t trim</span>
            <span class="k">yield</span> <span class="n">record</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># trim off the adaptor</span>
            <span class="k">yield</span> <span class="n">record</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="n">len_adaptor</span> <span class="p">:]</span>


<span class="n">original_reads</span> <span class="o">=</span> <span class="n">SeqIO</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;SRR020192.fastq&quot;</span><span class="p">,</span> <span class="s2">&quot;fastq&quot;</span><span class="p">)</span>
<span class="n">trimmed_reads</span> <span class="o">=</span> <span class="n">trim_adaptors</span><span class="p">(</span><span class="n">original_reads</span><span class="p">,</span> <span class="s2">&quot;GATGACGGTGT&quot;</span><span class="p">)</span>
<span class="n">count</span> <span class="o">=</span> <span class="n">SeqIO</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">trimmed_reads</span><span class="p">,</span> <span class="s2">&quot;trimmed.fastq&quot;</span><span class="p">,</span> <span class="s2">&quot;fastq&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Saved </span><span class="si">%i</span><span class="s2"> reads&quot;</span> <span class="o">%</span> <span class="n">count</span><span class="p">)</span>
</pre></div>
</div>
<p>Because we are using a FASTQ input file in this example, the
<code class="docutils literal notranslate"><span class="pre">SeqRecord</span></code> objects have per-letter-annotation for the quality scores.
By slicing the <code class="docutils literal notranslate"><span class="pre">SeqRecord</span></code> object the appropriate scores are used on
the trimmed records, so we can output them as a FASTQ file too.</p>
<p>Compared to the output of the previous example where we only looked for
a primer/adaptor at the start of each read, you may find some of the
trimmed reads are quite short after trimming (e.g. if the adaptor was
found in the middle rather than near the start). So, let’s add a minimum
length requirement as well:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">Bio</span> <span class="kn">import</span> <span class="n">SeqIO</span>


<span class="k">def</span> <span class="nf">trim_adaptors</span><span class="p">(</span><span class="n">records</span><span class="p">,</span> <span class="n">adaptor</span><span class="p">,</span> <span class="n">min_len</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Trims perfect adaptor sequences, checks read length.</span>

<span class="sd">    This is a generator function, the records argument should</span>
<span class="sd">    be a list or iterator returning SeqRecord objects.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">len_adaptor</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">adaptor</span><span class="p">)</span>  <span class="c1"># cache this for later</span>
    <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">records</span><span class="p">:</span>
        <span class="n">len_record</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">record</span><span class="p">)</span>  <span class="c1"># cache this for later</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">record</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">min_len</span><span class="p">:</span>
            <span class="c1"># Too short to keep</span>
            <span class="k">continue</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">record</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">adaptor</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="c1"># adaptor not found, so won&#39;t trim</span>
            <span class="k">yield</span> <span class="n">record</span>
        <span class="k">elif</span> <span class="n">len_record</span> <span class="o">-</span> <span class="n">index</span> <span class="o">-</span> <span class="n">len_adaptor</span> <span class="o">&gt;=</span> <span class="n">min_len</span><span class="p">:</span>
            <span class="c1"># after trimming this will still be long enough</span>
            <span class="k">yield</span> <span class="n">record</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="n">len_adaptor</span> <span class="p">:]</span>


<span class="n">original_reads</span> <span class="o">=</span> <span class="n">SeqIO</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;SRR020192.fastq&quot;</span><span class="p">,</span> <span class="s2">&quot;fastq&quot;</span><span class="p">)</span>
<span class="n">trimmed_reads</span> <span class="o">=</span> <span class="n">trim_adaptors</span><span class="p">(</span><span class="n">original_reads</span><span class="p">,</span> <span class="s2">&quot;GATGACGGTGT&quot;</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">count</span> <span class="o">=</span> <span class="n">SeqIO</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">trimmed_reads</span><span class="p">,</span> <span class="s2">&quot;trimmed.fastq&quot;</span><span class="p">,</span> <span class="s2">&quot;fastq&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Saved </span><span class="si">%i</span><span class="s2"> reads&quot;</span> <span class="o">%</span> <span class="n">count</span><span class="p">)</span>
</pre></div>
</div>
<p>By changing the format names, you could apply this to FASTA files
instead. This code also could be extended to do a fuzzy match instead of
an exact match (maybe using a pairwise alignment, or taking into account
the read quality scores), but that will be much slower.</p>
</section>
<section id="converting-fastq-files">
<span id="sec-seqio-fastq-conversion"></span><h3>Converting FASTQ files<a class="headerlink" href="#converting-fastq-files" title="Link to this heading"></a></h3>
<p>Back in Section <a class="reference internal" href="chapter_seqio.html#sec-seqio-conversion"><span class="std std-ref">Converting between sequence file formats</span></a> we
showed how to use <code class="docutils literal notranslate"><span class="pre">Bio.SeqIO</span></code> to convert between two file formats.
Here we’ll go into a little more detail regarding FASTQ files which are
used in second generation DNA sequencing. Please refer to Cock <em>et al.</em>
(2010) <a class="reference internal" href="chapter_bibliography.html#cock2010" id="id1"><span>[Cock2010]</span></a> for a longer description. FASTQ
files store both the DNA sequence (as a string) and the associated read
qualities.</p>
<p>PHRED scores (used in most FASTQ files, and also in QUAL files, ACE
files and SFF files) have become a <em>de facto</em> standard for representing
the probability of a sequencing error (here denoted by <span class="math notranslate nohighlight">\(P_e\)</span>) at a
given base using a simple base ten log transformation:</p>
<div class="math notranslate nohighlight">
\[Q_{\textrm{PHRED}} = - 10 \times \textrm{log}_{10} ( P_e )\]</div>
<p>This means a wrong read (<span class="math notranslate nohighlight">\(P_e = 1\)</span>) gets a PHRED quality of
<span class="math notranslate nohighlight">\(0\)</span>, while a very good read like <span class="math notranslate nohighlight">\(P_e = 0.00001\)</span> gets a
PHRED quality of <span class="math notranslate nohighlight">\(50\)</span>. While for raw sequencing data qualities
higher than this are rare, with post processing such as read mapping or
assembly, qualities of up to about <span class="math notranslate nohighlight">\(90\)</span> are possible (indeed, the
MAQ tool allows for PHRED scores in the range 0 to 93 inclusive).</p>
<p>The FASTQ format has the potential to become a <em>de facto</em> standard for
storing the letters and quality scores for a sequencing read in a single
plain text file. The only fly in the ointment is that there are at least
three versions of the FASTQ format which are incompatible and difficult
to distinguish…</p>
<ol class="arabic simple">
<li><p>The original Sanger FASTQ format uses PHRED qualities encoded with an
ASCII offset of 33. The NCBI are using this format in their Short
Read Archive. We call this the <code class="docutils literal notranslate"><span class="pre">fastq</span></code> (or <code class="docutils literal notranslate"><span class="pre">fastq-sanger</span></code>) format
in <code class="docutils literal notranslate"><span class="pre">Bio.SeqIO</span></code>.</p></li>
<li><p>Solexa (later bought by Illumina) introduced their own version using
Solexa qualities encoded with an ASCII offset of 64. We call this the
<code class="docutils literal notranslate"><span class="pre">fastq-solexa</span></code> format.</p></li>
<li><p>Illumina pipeline 1.3 onwards produces FASTQ files with PHRED
qualities (which is more consistent), but encoded with an ASCII
offset of 64. We call this the <code class="docutils literal notranslate"><span class="pre">fastq-illumina</span></code> format.</p></li>
</ol>
<p>The Solexa quality scores are defined using a different log
transformation:</p>
<div class="math notranslate nohighlight">
\[Q_{\textrm{Solexa}} = - 10 \times \textrm{log}_{10} \left( \frac{P_e}{1-P_e} \right)\]</div>
<p>Given Solexa/Illumina have now moved to using PHRED scores in version
1.3 of their pipeline, the Solexa quality scores will gradually fall out
of use. If you equate the error estimates (<span class="math notranslate nohighlight">\(P_e\)</span>) these two
equations allow conversion between the two scoring systems - and
Biopython includes functions to do this in the <code class="docutils literal notranslate"><span class="pre">Bio.SeqIO.QualityIO</span></code>
module, which are called if you use <code class="docutils literal notranslate"><span class="pre">Bio.SeqIO</span></code> to convert an old
Solexa/Illumina file into a standard Sanger FASTQ file:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">Bio</span> <span class="kn">import</span> <span class="n">SeqIO</span>

<span class="n">SeqIO</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="s2">&quot;solexa.fastq&quot;</span><span class="p">,</span> <span class="s2">&quot;fastq-solexa&quot;</span><span class="p">,</span> <span class="s2">&quot;standard.fastq&quot;</span><span class="p">,</span> <span class="s2">&quot;fastq&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>If you want to convert a new Illumina 1.3+ FASTQ file, all that gets
changed is the ASCII offset because although encoded differently the
scores are all PHRED qualities:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">Bio</span> <span class="kn">import</span> <span class="n">SeqIO</span>

<span class="n">SeqIO</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="s2">&quot;illumina.fastq&quot;</span><span class="p">,</span> <span class="s2">&quot;fastq-illumina&quot;</span><span class="p">,</span> <span class="s2">&quot;standard.fastq&quot;</span><span class="p">,</span> <span class="s2">&quot;fastq&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that using <code class="docutils literal notranslate"><span class="pre">Bio.SeqIO.convert()</span></code> like this is <em>much</em> faster than
combining <code class="docutils literal notranslate"><span class="pre">Bio.SeqIO.parse()</span></code> and <code class="docutils literal notranslate"><span class="pre">Bio.SeqIO.write()</span></code> because
optimized code is used for converting between FASTQ variants (and also
for FASTQ to FASTA conversion).</p>
<p>For good quality reads, PHRED and Solexa scores are approximately equal,
which means since both the <code class="docutils literal notranslate"><span class="pre">fasta-solexa</span></code> and <code class="docutils literal notranslate"><span class="pre">fastq-illumina</span></code>
formats use an ASCII offset of 64 the files are almost the same. This
was a deliberate design choice by Illumina, meaning applications
expecting the old <code class="docutils literal notranslate"><span class="pre">fasta-solexa</span></code> style files will probably be OK using
the newer <code class="docutils literal notranslate"><span class="pre">fastq-illumina</span></code> files (on good data). Of course, both
variants are very different from the original FASTQ standard as used by
Sanger, the NCBI, and elsewhere (format name <code class="docutils literal notranslate"><span class="pre">fastq</span></code> or
<code class="docutils literal notranslate"><span class="pre">fastq-sanger</span></code>).</p>
<p>For more details, see the built in help (also
<a class="reference external" href="http://www.biopython.org/docs/bpversion/api/Bio.SeqIO.QualityIO.html">online</a>):</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.SeqIO</span> <span class="kn">import</span> <span class="n">QualityIO</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">help</span><span class="p">(</span><span class="n">QualityIO</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="converting-fasta-and-qual-files-into-fastq-files">
<span id="sec-seqio-fasta-qual-conversion"></span><h3>Converting FASTA and QUAL files into FASTQ files<a class="headerlink" href="#converting-fasta-and-qual-files-into-fastq-files" title="Link to this heading"></a></h3>
<p>FASTQ files hold <em>both</em> sequences and their quality strings. FASTA files
hold <em>just</em> sequences, while QUAL files hold <em>just</em> the qualities.
Therefore a single FASTQ file can be converted to or from <em>paired</em> FASTA
and QUAL files.</p>
<p>Going from FASTQ to FASTA is easy:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">Bio</span> <span class="kn">import</span> <span class="n">SeqIO</span>

<span class="n">SeqIO</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="s2">&quot;example.fastq&quot;</span><span class="p">,</span> <span class="s2">&quot;fastq&quot;</span><span class="p">,</span> <span class="s2">&quot;example.fasta&quot;</span><span class="p">,</span> <span class="s2">&quot;fasta&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Going from FASTQ to QUAL is also easy:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">Bio</span> <span class="kn">import</span> <span class="n">SeqIO</span>

<span class="n">SeqIO</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="s2">&quot;example.fastq&quot;</span><span class="p">,</span> <span class="s2">&quot;fastq&quot;</span><span class="p">,</span> <span class="s2">&quot;example.qual&quot;</span><span class="p">,</span> <span class="s2">&quot;qual&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>However, the reverse is a little more tricky. You can use
<code class="docutils literal notranslate"><span class="pre">Bio.SeqIO.parse()</span></code> to iterate over the records in a <em>single</em> file,
but in this case we have two input files. There are several strategies
possible, but assuming that the two files are really paired the most
memory efficient way is to loop over both together. The code is a little
fiddly, so we provide a function called <code class="docutils literal notranslate"><span class="pre">PairedFastaQualIterator</span></code> in
the <code class="docutils literal notranslate"><span class="pre">Bio.SeqIO.QualityIO</span></code> module to do this. This takes two handles
(the FASTA file and the QUAL file) and returns a <code class="docutils literal notranslate"><span class="pre">SeqRecord</span></code> iterator:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">Bio.SeqIO.QualityIO</span> <span class="kn">import</span> <span class="n">PairedFastaQualIterator</span>

<span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">PairedFastaQualIterator</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="s2">&quot;example.fasta&quot;</span><span class="p">),</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;example.qual&quot;</span><span class="p">)):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">record</span><span class="p">)</span>
</pre></div>
</div>
<p>This function will check that the FASTA and QUAL files are consistent
(e.g. the records are in the same order, and have the same sequence
length). You can combine this with the <code class="docutils literal notranslate"><span class="pre">Bio.SeqIO.write()</span></code> function to
convert a pair of FASTA and QUAL files into a single FASTQ files:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">Bio</span> <span class="kn">import</span> <span class="n">SeqIO</span>
<span class="kn">from</span> <span class="nn">Bio.SeqIO.QualityIO</span> <span class="kn">import</span> <span class="n">PairedFastaQualIterator</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;example.fasta&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f_handle</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;example.qual&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">q_handle</span><span class="p">:</span>
    <span class="n">records</span> <span class="o">=</span> <span class="n">PairedFastaQualIterator</span><span class="p">(</span><span class="n">f_handle</span><span class="p">,</span> <span class="n">q_handle</span><span class="p">)</span>
    <span class="n">count</span> <span class="o">=</span> <span class="n">SeqIO</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">records</span><span class="p">,</span> <span class="s2">&quot;temp.fastq&quot;</span><span class="p">,</span> <span class="s2">&quot;fastq&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Converted </span><span class="si">%i</span><span class="s2"> records&quot;</span> <span class="o">%</span> <span class="n">count</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="indexing-a-fastq-file">
<span id="sec-fastq-indexing"></span><h3>Indexing a FASTQ file<a class="headerlink" href="#indexing-a-fastq-file" title="Link to this heading"></a></h3>
<p>FASTQ files are usually very large, with millions of reads in them. Due
to the sheer amount of data, you can’t load all the records into memory
at once. This is why the examples above (filtering and trimming) iterate
over the file looking at just one <code class="docutils literal notranslate"><span class="pre">SeqRecord</span></code> at a time.</p>
<p>However, sometimes you can’t use a big loop or an iterator - you may
need random access to the reads. Here the <code class="docutils literal notranslate"><span class="pre">Bio.SeqIO.index()</span></code> function
may prove very helpful, as it allows you to access any read in the FASTQ
file by its name (see Section <a class="reference internal" href="chapter_seqio.html#sec-seqio-index"><span class="std std-ref">Sequence files as Dictionaries – Indexed files</span></a>).</p>
<p>Again we’ll use the <code class="docutils literal notranslate"><span class="pre">SRR020192.fastq</span></code> file from the ENA
(<a class="reference external" href="ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR020/SRR020192/SRR020192.fastq.gz">ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR020/SRR020192/SRR020192.fastq.gz</a>),
although this is actually quite a small FASTQ file with less than
<span class="math notranslate nohighlight">\(50,000\)</span> reads:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio</span> <span class="kn">import</span> <span class="n">SeqIO</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fq_dict</span> <span class="o">=</span> <span class="n">SeqIO</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;SRR020192.fastq&quot;</span><span class="p">,</span> <span class="s2">&quot;fastq&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">fq_dict</span><span class="p">)</span>
<span class="go">41892</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">fq_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())[:</span><span class="mi">4</span><span class="p">]</span>
<span class="go">[&#39;SRR020192.38240&#39;, &#39;SRR020192.23181&#39;, &#39;SRR020192.40568&#39;, &#39;SRR020192.23186&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fq_dict</span><span class="p">[</span><span class="s2">&quot;SRR020192.23186&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">seq</span>
<span class="go">Seq(&#39;GTCCCAGTATTCGGATTTGTCTGCCAAAACAATGAAATTGACACAGTTTACAAC...CCG&#39;)</span>
</pre></div>
</div>
<p>When testing this on a FASTQ file with seven million reads, indexing
took about a minute, but record access was almost instant.</p>
<p>The sister function <code class="docutils literal notranslate"><span class="pre">Bio.SeqIO.index_db()</span></code> lets you save the index to
an SQLite3 database file for near instantaneous reuse - see
Section <a class="reference internal" href="chapter_seqio.html#sec-seqio-index"><span class="std std-ref">Sequence files as Dictionaries – Indexed files</span></a> for more details.</p>
<p>The example in Section <a class="reference internal" href="#sec-seqio-sort"><span class="std std-ref">Sorting a sequence file</span></a> show how you can use
the <code class="docutils literal notranslate"><span class="pre">Bio.SeqIO.index()</span></code> function to sort a large FASTA file – this
could also be used on FASTQ files.</p>
</section>
<section id="converting-sff-files">
<span id="sec-seqio-sff-conversion"></span><h3>Converting SFF files<a class="headerlink" href="#converting-sff-files" title="Link to this heading"></a></h3>
<p>If you work with 454 (Roche) sequence data, you will probably have
access to the raw data as a Standard Flowgram Format (SFF) file. This
contains the sequence reads (called bases) with quality scores and the
original flow information.</p>
<p>A common task is to convert from SFF to a pair of FASTA and QUAL files,
or to a single FASTQ file. These operations are trivial using the
<code class="docutils literal notranslate"><span class="pre">Bio.SeqIO.convert()</span></code> function (see
Section <a class="reference internal" href="chapter_seqio.html#sec-seqio-conversion"><span class="std std-ref">Converting between sequence file formats</span></a>):</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio</span> <span class="kn">import</span> <span class="n">SeqIO</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SeqIO</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="s2">&quot;E3MFGYR02_random_10_reads.sff&quot;</span><span class="p">,</span> <span class="s2">&quot;sff&quot;</span><span class="p">,</span> <span class="s2">&quot;reads.fasta&quot;</span><span class="p">,</span> <span class="s2">&quot;fasta&quot;</span><span class="p">)</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SeqIO</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="s2">&quot;E3MFGYR02_random_10_reads.sff&quot;</span><span class="p">,</span> <span class="s2">&quot;sff&quot;</span><span class="p">,</span> <span class="s2">&quot;reads.qual&quot;</span><span class="p">,</span> <span class="s2">&quot;qual&quot;</span><span class="p">)</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SeqIO</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="s2">&quot;E3MFGYR02_random_10_reads.sff&quot;</span><span class="p">,</span> <span class="s2">&quot;sff&quot;</span><span class="p">,</span> <span class="s2">&quot;reads.fastq&quot;</span><span class="p">,</span> <span class="s2">&quot;fastq&quot;</span><span class="p">)</span>
<span class="go">10</span>
</pre></div>
</div>
<p>Remember the convert function returns the number of records, in this
example just ten. This will give you the <em>untrimmed</em> reads, where the
leading and trailing poor quality sequence or adaptor will be in lower
case. If you want the <em>trimmed</em> reads (using the clipping information
recorded within the SFF file) use this:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio</span> <span class="kn">import</span> <span class="n">SeqIO</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SeqIO</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="s2">&quot;E3MFGYR02_random_10_reads.sff&quot;</span><span class="p">,</span> <span class="s2">&quot;sff-trim&quot;</span><span class="p">,</span> <span class="s2">&quot;trimmed.fasta&quot;</span><span class="p">,</span> <span class="s2">&quot;fasta&quot;</span><span class="p">)</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SeqIO</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="s2">&quot;E3MFGYR02_random_10_reads.sff&quot;</span><span class="p">,</span> <span class="s2">&quot;sff-trim&quot;</span><span class="p">,</span> <span class="s2">&quot;trimmed.qual&quot;</span><span class="p">,</span> <span class="s2">&quot;qual&quot;</span><span class="p">)</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SeqIO</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="s2">&quot;E3MFGYR02_random_10_reads.sff&quot;</span><span class="p">,</span> <span class="s2">&quot;sff-trim&quot;</span><span class="p">,</span> <span class="s2">&quot;trimmed.fastq&quot;</span><span class="p">,</span> <span class="s2">&quot;fastq&quot;</span><span class="p">)</span>
<span class="go">10</span>
</pre></div>
</div>
<p>If you run Linux, you could ask Roche for a copy of their “off
instrument” tools (often referred to as the Newbler tools). This offers
an alternative way to do SFF to FASTA or QUAL conversion at the command
line (but currently FASTQ output is not supported), e.g.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>sffinfo<span class="w"> </span>-seq<span class="w"> </span>-notrim<span class="w"> </span>E3MFGYR02_random_10_reads.sff<span class="w"> </span>&gt;<span class="w"> </span>reads.fasta
<span class="gp">$ </span>sffinfo<span class="w"> </span>-qual<span class="w"> </span>-notrim<span class="w"> </span>E3MFGYR02_random_10_reads.sff<span class="w"> </span>&gt;<span class="w"> </span>reads.qual
<span class="gp">$ </span>sffinfo<span class="w"> </span>-seq<span class="w"> </span>-trim<span class="w"> </span>E3MFGYR02_random_10_reads.sff<span class="w"> </span>&gt;<span class="w"> </span>trimmed.fasta
<span class="gp">$ </span>sffinfo<span class="w"> </span>-qual<span class="w"> </span>-trim<span class="w"> </span>E3MFGYR02_random_10_reads.sff<span class="w"> </span>&gt;<span class="w"> </span>trimmed.qual
</pre></div>
</div>
<p>The way Biopython uses mixed case sequence strings to represent the
trimming points deliberately mimics what the Roche tools do.</p>
<p>For more information on the Biopython SFF support, consult the built in
help:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.SeqIO</span> <span class="kn">import</span> <span class="n">SffIO</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">help</span><span class="p">(</span><span class="n">SffIO</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="identifying-open-reading-frames">
<h3>Identifying open reading frames<a class="headerlink" href="#identifying-open-reading-frames" title="Link to this heading"></a></h3>
<p>A very simplistic first step at identifying possible genes is to look
for open reading frames (ORFs). By this we mean look in all six frames
for long regions without stop codons – an ORF is just a region of
nucleotides with no in frame stop codons.</p>
<p>Of course, to find a gene you would also need to worry about locating a
start codon, possible promoters – and in Eukaryotes there are introns to
worry about too. However, this approach is still useful in viruses and
Prokaryotes.</p>
<p>To show how you might approach this with Biopython, we’ll need a
sequence to search, and as an example we’ll again use the bacterial
plasmid – although this time we’ll start with a plain FASTA file with no
pre-marked genes:
<code class="docutils literal notranslate"><span class="pre">`NC_005816.fna</span></code> &lt;<a class="reference external" href="https://raw.githubusercontent.com/biopython/biopython/master/Tests/GenBank/NC_005816.fna">https://raw.githubusercontent.com/biopython/biopython/master/Tests/GenBank/NC_005816.fna</a>&gt;`__.
This is a bacterial sequence, so we’ll want to use NCBI codon table 11
(see Section <a class="reference internal" href="chapter_seq_objects.html#sec-translation"><span class="std std-ref">Translation</span></a> about
translation).</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio</span> <span class="kn">import</span> <span class="n">SeqIO</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">record</span> <span class="o">=</span> <span class="n">SeqIO</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s2">&quot;NC_005816.fna&quot;</span><span class="p">,</span> <span class="s2">&quot;fasta&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">table</span> <span class="o">=</span> <span class="mi">11</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">min_pro_len</span> <span class="o">=</span> <span class="mi">100</span>
</pre></div>
</div>
<p>Here is a neat trick using the <code class="docutils literal notranslate"><span class="pre">Seq</span></code> object’s <code class="docutils literal notranslate"><span class="pre">split</span></code> method to get
a list of all the possible ORF translations in the six reading frames:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">strand</span><span class="p">,</span> <span class="n">nuc</span> <span class="ow">in</span> <span class="p">[(</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">record</span><span class="o">.</span><span class="n">seq</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">record</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">reverse_complement</span><span class="p">())]:</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">frame</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
<span class="gp">... </span>        <span class="n">length</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">record</span><span class="p">)</span> <span class="o">-</span> <span class="n">frame</span><span class="p">)</span> <span class="o">//</span> <span class="mi">3</span><span class="p">)</span>  <span class="c1"># Multiple of three</span>
<span class="gp">... </span>        <span class="k">for</span> <span class="n">pro</span> <span class="ow">in</span> <span class="n">nuc</span><span class="p">[</span><span class="n">frame</span> <span class="p">:</span> <span class="n">frame</span> <span class="o">+</span> <span class="n">length</span><span class="p">]</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">table</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;*&quot;</span><span class="p">):</span>
<span class="gp">... </span>            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pro</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">min_pro_len</span><span class="p">:</span>
<span class="gp">... </span>                <span class="nb">print</span><span class="p">(</span>
<span class="gp">... </span>                    <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">...</span><span class="si">%s</span><span class="s2"> - length </span><span class="si">%i</span><span class="s2">, strand </span><span class="si">%i</span><span class="s2">, frame </span><span class="si">%i</span><span class="s2">&quot;</span>
<span class="gp">... </span>                    <span class="o">%</span> <span class="p">(</span><span class="n">pro</span><span class="p">[:</span><span class="mi">30</span><span class="p">],</span> <span class="n">pro</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:],</span> <span class="nb">len</span><span class="p">(</span><span class="n">pro</span><span class="p">),</span> <span class="n">strand</span><span class="p">,</span> <span class="n">frame</span><span class="p">)</span>
<span class="gp">... </span>                <span class="p">)</span>
<span class="gp">...</span>
<span class="go">GCLMKKSSIVATIITILSGSANAASSQLIP...YRF - length 315, strand 1, frame 0</span>
<span class="go">KSGELRQTPPASSTLHLRLILQRSGVMMEL...NPE - length 285, strand 1, frame 1</span>
<span class="go">GLNCSFFSICNWKFIDYINRLFQIIYLCKN...YYH - length 176, strand 1, frame 1</span>
<span class="go">VKKILYIKALFLCTVIKLRRFIFSVNNMKF...DLP - length 165, strand 1, frame 1</span>
<span class="go">NQIQGVICSPDSGEFMVTFETVMEIKILHK...GVA - length 355, strand 1, frame 2</span>
<span class="go">RRKEHVSKKRRPQKRPRRRRFFHRLRPPDE...PTR - length 128, strand 1, frame 2</span>
<span class="go">TGKQNSCQMSAIWQLRQNTATKTRQNRARI...AIK - length 100, strand 1, frame 2</span>
<span class="go">QGSGYAFPHASILSGIAMSHFYFLVLHAVK...CSD - length 114, strand -1, frame 0</span>
<span class="go">IYSTSEHTGEQVMRTLDEVIASRSPESQTR...FHV - length 111, strand -1, frame 0</span>
<span class="go">WGKLQVIGLSMWMVLFSQRFDDWLNEQEDA...ESK - length 125, strand -1, frame 1</span>
<span class="go">RGIFMSDTMVVNGSGGVPAFLFSGSTLSSY...LLK - length 361, strand -1, frame 1</span>
<span class="go">WDVKTVTGVLHHPFHLTFSLCPEGATQSGR...VKR - length 111, strand -1, frame 1</span>
<span class="go">LSHTVTDFTDQMAQVGLCQCVNVFLDEVTG...KAA - length 107, strand -1, frame 2</span>
<span class="go">RALTGLSAPGIRSQTSCDRLRELRYVPVSL...PLQ - length 119, strand -1, frame 2</span>
</pre></div>
</div>
<p>Note that here we are counting the frames from the 5’ end (start) of
<em>each</em> strand. It is sometimes easier to always count from the 5’ end
(start) of the <em>forward</em> strand.</p>
<p>You could easily edit the above loop based code to build up a list of
the candidate proteins, or convert this to a list comprehension. Now,
one thing this code doesn’t do is keep track of where the proteins are.</p>
<p>You could tackle this in several ways. For example, the following code
tracks the locations in terms of the protein counting, and converts back
to the parent sequence by multiplying by three, then adjusting for the
frame and strand:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">Bio</span> <span class="kn">import</span> <span class="n">SeqIO</span>

<span class="n">record</span> <span class="o">=</span> <span class="n">SeqIO</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s2">&quot;NC_005816.gb&quot;</span><span class="p">,</span> <span class="s2">&quot;genbank&quot;</span><span class="p">)</span>
<span class="n">table</span> <span class="o">=</span> <span class="mi">11</span>
<span class="n">min_pro_len</span> <span class="o">=</span> <span class="mi">100</span>


<span class="k">def</span> <span class="nf">find_orfs_with_trans</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">trans_table</span><span class="p">,</span> <span class="n">min_protein_length</span><span class="p">):</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">seq_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">strand</span><span class="p">,</span> <span class="n">nuc</span> <span class="ow">in</span> <span class="p">[(</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">seq</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">seq</span><span class="o">.</span><span class="n">reverse_complement</span><span class="p">())]:</span>
        <span class="k">for</span> <span class="n">frame</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="n">trans</span> <span class="o">=</span> <span class="n">nuc</span><span class="p">[</span><span class="n">frame</span><span class="p">:]</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">trans_table</span><span class="p">)</span>
            <span class="n">trans_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">trans</span><span class="p">)</span>
            <span class="n">aa_start</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">aa_end</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="n">aa_start</span> <span class="o">&lt;</span> <span class="n">trans_len</span><span class="p">:</span>
                <span class="n">aa_end</span> <span class="o">=</span> <span class="n">trans</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="n">aa_start</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">aa_end</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">aa_end</span> <span class="o">=</span> <span class="n">trans_len</span>
                <span class="k">if</span> <span class="n">aa_end</span> <span class="o">-</span> <span class="n">aa_start</span> <span class="o">&gt;=</span> <span class="n">min_protein_length</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">strand</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">start</span> <span class="o">=</span> <span class="n">frame</span> <span class="o">+</span> <span class="n">aa_start</span> <span class="o">*</span> <span class="mi">3</span>
                        <span class="n">end</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">seq_len</span><span class="p">,</span> <span class="n">frame</span> <span class="o">+</span> <span class="n">aa_end</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">start</span> <span class="o">=</span> <span class="n">seq_len</span> <span class="o">-</span> <span class="n">frame</span> <span class="o">-</span> <span class="n">aa_end</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">-</span> <span class="mi">3</span>
                        <span class="n">end</span> <span class="o">=</span> <span class="n">seq_len</span> <span class="o">-</span> <span class="n">frame</span> <span class="o">-</span> <span class="n">aa_start</span> <span class="o">*</span> <span class="mi">3</span>
                    <span class="n">answer</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">strand</span><span class="p">,</span> <span class="n">trans</span><span class="p">[</span><span class="n">aa_start</span><span class="p">:</span><span class="n">aa_end</span><span class="p">]))</span>
                <span class="n">aa_start</span> <span class="o">=</span> <span class="n">aa_end</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">answer</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">answer</span>


<span class="n">orf_list</span> <span class="o">=</span> <span class="n">find_orfs_with_trans</span><span class="p">(</span><span class="n">record</span><span class="o">.</span><span class="n">seq</span><span class="p">,</span> <span class="n">table</span><span class="p">,</span> <span class="n">min_pro_len</span><span class="p">)</span>
<span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">strand</span><span class="p">,</span> <span class="n">pro</span> <span class="ow">in</span> <span class="n">orf_list</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span>
        <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">...</span><span class="si">%s</span><span class="s2"> - length </span><span class="si">%i</span><span class="s2">, strand </span><span class="si">%i</span><span class="s2">, </span><span class="si">%i</span><span class="s2">:</span><span class="si">%i</span><span class="s2">&quot;</span>
        <span class="o">%</span> <span class="p">(</span><span class="n">pro</span><span class="p">[:</span><span class="mi">30</span><span class="p">],</span> <span class="n">pro</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:],</span> <span class="nb">len</span><span class="p">(</span><span class="n">pro</span><span class="p">),</span> <span class="n">strand</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
    <span class="p">)</span>
</pre></div>
</div>
<p>And the output:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>NQIQGVICSPDSGEFMVTFETVMEIKILHK...GVA - length 355, strand 1, 41:1109
WDVKTVTGVLHHPFHLTFSLCPEGATQSGR...VKR - length 111, strand -1, 491:827
KSGELRQTPPASSTLHLRLILQRSGVMMEL...NPE - length 285, strand 1, 1030:1888
RALTGLSAPGIRSQTSCDRLRELRYVPVSL...PLQ - length 119, strand -1, 2830:3190
RRKEHVSKKRRPQKRPRRRRFFHRLRPPDE...PTR - length 128, strand 1, 3470:3857
GLNCSFFSICNWKFIDYINRLFQIIYLCKN...YYH - length 176, strand 1, 4249:4780
RGIFMSDTMVVNGSGGVPAFLFSGSTLSSY...LLK - length 361, strand -1, 4814:5900
VKKILYIKALFLCTVIKLRRFIFSVNNMKF...DLP - length 165, strand 1, 5923:6421
LSHTVTDFTDQMAQVGLCQCVNVFLDEVTG...KAA - length 107, strand -1, 5974:6298
GCLMKKSSIVATIITILSGSANAASSQLIP...YRF - length 315, strand 1, 6654:7602
IYSTSEHTGEQVMRTLDEVIASRSPESQTR...FHV - length 111, strand -1, 7788:8124
WGKLQVIGLSMWMVLFSQRFDDWLNEQEDA...ESK - length 125, strand -1, 8087:8465
TGKQNSCQMSAIWQLRQNTATKTRQNRARI...AIK - length 100, strand 1, 8741:9044
QGSGYAFPHASILSGIAMSHFYFLVLHAVK...CSD - length 114, strand -1, 9264:9609
</pre></div>
</div>
<p>If you comment out the sort statement, then the protein sequences will
be shown in the same order as before, so you can check this is doing the
same thing. Here we have sorted them by location to make it easier to
compare to the actual annotation in the GenBank file (as visualized in
Section <a class="reference internal" href="chapter_graphics.html#sec-gd-nice-example"><span class="std std-ref">A nice example</span></a>).</p>
<p>If however all you want to find are the locations of the open reading
frames, then it is a waste of time to translate every possible codon,
including doing the reverse complement to search the reverse strand too.
All you need to do is search for the possible stop codons (and their
reverse complements). Using regular expressions is an obvious approach
here (see the Python module <code class="docutils literal notranslate"><span class="pre">re</span></code>). These are an extremely powerful
(but rather complex) way of describing search strings, which are
supported in lots of programming languages and also command line tools
like <code class="docutils literal notranslate"><span class="pre">grep</span></code> as well). You can find whole books about this topic!</p>
</section>
</section>
<section id="sequence-parsing-plus-simple-plots">
<span id="sec-sequence-parsing-plus-pylab"></span><h2>Sequence parsing plus simple plots<a class="headerlink" href="#sequence-parsing-plus-simple-plots" title="Link to this heading"></a></h2>
<p>This section shows some more examples of sequence parsing, using the
<code class="docutils literal notranslate"><span class="pre">Bio.SeqIO</span></code> module described in
Chapter <a class="reference internal" href="chapter_seqio.html#chapter-seqio"><span class="std std-ref">Sequence Input/Output</span></a>, plus the Python library
matplotlib’s <code class="docutils literal notranslate"><span class="pre">pylab</span></code> plotting interface (see <a class="reference external" href="https://matplotlib.org">the matplotlib website
for a tutorial</a>). Note that to follow these
examples you will need matplotlib installed - but without it you can
still try the data parsing bits.</p>
<section id="histogram-of-sequence-lengths">
<h3>Histogram of sequence lengths<a class="headerlink" href="#histogram-of-sequence-lengths" title="Link to this heading"></a></h3>
<p>There are lots of times when you might want to visualize the
distribution of sequence lengths in a dataset – for example the range of
contig sizes in a genome assembly project. In this example we’ll reuse
our orchid FASTA file
<a class="reference external" href="https://raw.githubusercontent.com/biopython/biopython/master/Doc/examples/ls_orchid.fasta">ls_orchid.fasta</a>
which has only 94 sequences.</p>
<p>First of all, we will use <code class="docutils literal notranslate"><span class="pre">Bio.SeqIO</span></code> to parse the FASTA file and
compile a list of all the sequence lengths. You could do this with a for
loop, but I find a list comprehension more pleasing:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio</span> <span class="kn">import</span> <span class="n">SeqIO</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sizes</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">rec</span><span class="p">)</span> <span class="k">for</span> <span class="n">rec</span> <span class="ow">in</span> <span class="n">SeqIO</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;ls_orchid.fasta&quot;</span><span class="p">,</span> <span class="s2">&quot;fasta&quot;</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">sizes</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">sizes</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">sizes</span><span class="p">)</span>
<span class="go">(94, 572, 789)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sizes</span>
<span class="go">[740, 753, 748, 744, 733, 718, 730, 704, 740, 709, 700, 726, ..., 592]</span>
</pre></div>
</div>
<p>Now that we have the lengths of all the genes (as a list of integers),
we can use the matplotlib histogram function to display it.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">Bio</span> <span class="kn">import</span> <span class="n">SeqIO</span>

<span class="n">sizes</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">rec</span><span class="p">)</span> <span class="k">for</span> <span class="n">rec</span> <span class="ow">in</span> <span class="n">SeqIO</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;ls_orchid.fasta&quot;</span><span class="p">,</span> <span class="s2">&quot;fasta&quot;</span><span class="p">)]</span>

<span class="kn">import</span> <span class="nn">pylab</span>

<span class="n">pylab</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">sizes</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">pylab</span><span class="o">.</span><span class="n">title</span><span class="p">(</span>
    <span class="s2">&quot;</span><span class="si">%i</span><span class="s2"> orchid sequences</span><span class="se">\n</span><span class="s2">Lengths </span><span class="si">%i</span><span class="s2"> to </span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sizes</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">sizes</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">sizes</span><span class="p">))</span>
<span class="p">)</span>
<span class="n">pylab</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Sequence length (bp)&quot;</span><span class="p">)</span>
<span class="n">pylab</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Count&quot;</span><span class="p">)</span>
<span class="n">pylab</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<figure class="align-default" id="fig-seq-len-hist">
<a class="reference internal image-reference" href="../_images/hist_plot.png"><img alt="Histogram of orchid sequence lengths." src="../_images/hist_plot.png" style="width: 80.0%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 22 </span><span class="caption-text">Histogram of orchid sequence lengths.</span><a class="headerlink" href="#fig-seq-len-hist" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>That should pop up a new window containing the graph shown in
<a class="reference internal" href="#fig-seq-len-hist"><span class="std std-numref">Fig. 22</span></a>. Notice that most of these orchid
sequences are about <span class="math notranslate nohighlight">\(740\)</span> bp long, and there could be two distinct
classes of sequence here with a subset of shorter sequences.</p>
<p><em>Tip:</em> Rather than using <code class="docutils literal notranslate"><span class="pre">pylab.show()</span></code> to show the plot in a window,
you can also use <code class="docutils literal notranslate"><span class="pre">pylab.savefig(...)</span></code> to save the figure to a file
(e.g. as a PNG or PDF).</p>
</section>
<section id="plot-of-sequence-gc">
<h3>Plot of sequence GC%<a class="headerlink" href="#plot-of-sequence-gc" title="Link to this heading"></a></h3>
<p>Another easily calculated quantity of a nucleotide sequence is the GC%.
You might want to look at the GC% of all the genes in a bacterial genome
for example, and investigate any outliers which could have been recently
acquired by horizontal gene transfer. Again, for this example we’ll
reuse our orchid FASTA file
<a class="reference external" href="https://raw.githubusercontent.com/biopython/biopython/master/Doc/examples/ls_orchid.fasta">ls_orchid.fasta</a>.</p>
<p>First of all, we will use <code class="docutils literal notranslate"><span class="pre">Bio.SeqIO</span></code> to parse the FASTA file and
compile a list of all the GC percentages. Again, you could do this with
a for loop, but I prefer this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">Bio</span> <span class="kn">import</span> <span class="n">SeqIO</span>
<span class="kn">from</span> <span class="nn">Bio.SeqUtils</span> <span class="kn">import</span> <span class="n">gc_fraction</span>

<span class="n">gc_values</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
    <span class="mi">100</span> <span class="o">*</span> <span class="n">gc_fraction</span><span class="p">(</span><span class="n">rec</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span> <span class="k">for</span> <span class="n">rec</span> <span class="ow">in</span> <span class="n">SeqIO</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;ls_orchid.fasta&quot;</span><span class="p">,</span> <span class="s2">&quot;fasta&quot;</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Having read in each sequence and calculated the GC%, we then sorted them
into ascending order. Now we’ll take this list of floating point values
and plot them with matplotlib:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pylab</span>

<span class="n">pylab</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">gc_values</span><span class="p">)</span>
<span class="n">pylab</span><span class="o">.</span><span class="n">title</span><span class="p">(</span>
    <span class="s2">&quot;</span><span class="si">%i</span><span class="s2"> orchid sequences</span><span class="se">\n</span><span class="s2">GC</span><span class="si">%%</span><span class="s2"> </span><span class="si">%0.1f</span><span class="s2"> to </span><span class="si">%0.1f</span><span class="s2">&quot;</span>
    <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gc_values</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">gc_values</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">gc_values</span><span class="p">))</span>
<span class="p">)</span>
<span class="n">pylab</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Genes&quot;</span><span class="p">)</span>
<span class="n">pylab</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;GC%&quot;</span><span class="p">)</span>
<span class="n">pylab</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<figure class="align-default" id="fig-seq-gc-plot">
<a class="reference internal image-reference" href="../_images/gc_plot.png"><img alt="Histogram of orchid sequence lengths." src="../_images/gc_plot.png" style="width: 80.0%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 23 </span><span class="caption-text">Histogram of orchid sequence lengths.</span><a class="headerlink" href="#fig-seq-gc-plot" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>As in the previous example, that should pop up a new window with the
graph shown in <a class="reference internal" href="#fig-seq-gc-plot"><span class="std std-numref">Fig. 23</span></a>. If you tried this on
the full set of genes from one organism, you’d probably get a much
smoother plot than this.</p>
</section>
<section id="nucleotide-dot-plots">
<h3>Nucleotide dot plots<a class="headerlink" href="#nucleotide-dot-plots" title="Link to this heading"></a></h3>
<p>A dot plot is a way of visually comparing two nucleotide sequences for
similarity to each other. A sliding window is used to compare short
sub-sequences to each other, often with a mismatch threshold. Here for
simplicity we’ll only look for perfect matches (shown in black in
<a class="reference internal" href="#fig-nuc-dot-plot"><span class="std std-numref">Fig. 24</span></a>).</p>
<figure class="align-default" id="fig-nuc-dot-plot">
<a class="reference internal image-reference" href="../_images/dot_plot.png"><img alt="Nucleotide dot plot of two orchid sequences using image show." src="../_images/dot_plot.png" style="width: 80.0%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 24 </span><span class="caption-text">Nucleotide dot plot of two orchid sequences using image show.</span><a class="headerlink" href="#fig-nuc-dot-plot" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>To start off, we’ll need two sequences. For the sake of argument, we’ll
just take the first two from our orchid FASTA file
<a class="reference external" href="https://raw.githubusercontent.com/biopython/biopython/master/Doc/examples/ls_orchid.fasta">ls_orchid.fasta</a>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">Bio</span> <span class="kn">import</span> <span class="n">SeqIO</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;ls_orchid.fasta&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">in_handle</span><span class="p">:</span>
    <span class="n">record_iterator</span> <span class="o">=</span> <span class="n">SeqIO</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">in_handle</span><span class="p">,</span> <span class="s2">&quot;fasta&quot;</span><span class="p">)</span>
    <span class="n">rec_one</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">record_iterator</span><span class="p">)</span>
    <span class="n">rec_two</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">record_iterator</span><span class="p">)</span>
</pre></div>
</div>
<p>We’re going to show two approaches. Firstly, a simple naive
implementation which compares all the window sized sub-sequences to each
other to compiles a similarity matrix. You could construct a matrix or
array object, but here we just use a list of lists of booleans created
with a nested list comprehension:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">window</span> <span class="o">=</span> <span class="mi">7</span>
<span class="n">seq_one</span> <span class="o">=</span> <span class="n">rec_one</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
<span class="n">seq_two</span> <span class="o">=</span> <span class="n">rec_two</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
<span class="n">data</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span>
        <span class="p">(</span><span class="n">seq_one</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">window</span><span class="p">]</span> <span class="o">!=</span> <span class="n">seq_two</span><span class="p">[</span><span class="n">j</span> <span class="p">:</span> <span class="n">j</span> <span class="o">+</span> <span class="n">window</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seq_one</span><span class="p">)</span> <span class="o">-</span> <span class="n">window</span><span class="p">)</span>
    <span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seq_two</span><span class="p">)</span> <span class="o">-</span> <span class="n">window</span><span class="p">)</span>
<span class="p">]</span>
</pre></div>
</div>
<p>Note that we have <em>not</em> checked for reverse complement matches here. Now
we’ll use the matplotlib’s <code class="docutils literal notranslate"><span class="pre">pylab.imshow()</span></code> function to display this
data, first requesting the gray color scheme so this is done in black
and white:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pylab</span>

<span class="n">pylab</span><span class="o">.</span><span class="n">gray</span><span class="p">()</span>
<span class="n">pylab</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="n">pylab</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> (length </span><span class="si">%i</span><span class="s2"> bp)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">rec_one</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">rec_one</span><span class="p">)))</span>
<span class="n">pylab</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> (length </span><span class="si">%i</span><span class="s2"> bp)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">rec_two</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">rec_two</span><span class="p">)))</span>
<span class="n">pylab</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Dot plot using window size </span><span class="si">%i</span><span class="se">\n</span><span class="s2">(allowing no mis-matches)&quot;</span> <span class="o">%</span> <span class="n">window</span><span class="p">)</span>
<span class="n">pylab</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>That should pop up a new window showing the graph in
<a class="reference internal" href="#fig-nuc-dot-plot"><span class="std std-numref">Fig. 24</span></a>. As you might have expected, these
two sequences are very similar with a partial line of window sized
matches along the diagonal. There are no off diagonal matches which
would be indicative of inversions or other interesting events.</p>
<p>The above code works fine on small examples, but there are two problems
applying this to larger sequences, which we will address below. First
off all, this brute force approach to the all against all comparisons is
very slow. Instead, we’ll compile dictionaries mapping the window sized
sub-sequences to their locations, and then take the set intersection to
find those sub-sequences found in both sequences. This uses more memory,
but is <em>much</em> faster. Secondly, the <code class="docutils literal notranslate"><span class="pre">pylab.imshow()</span></code> function is
limited in the size of matrix it can display. As an alternative, we’ll
use the <code class="docutils literal notranslate"><span class="pre">pylab.scatter()</span></code> function.</p>
<p>We start by creating dictionaries mapping the window-sized sub-sequences
to locations:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">window</span> <span class="o">=</span> <span class="mi">7</span>
<span class="n">dict_one</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">dict_two</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">seq</span><span class="p">,</span> <span class="n">section_dict</span> <span class="ow">in</span> <span class="p">[</span>
    <span class="p">(</span><span class="n">rec_one</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="n">dict_one</span><span class="p">),</span>
    <span class="p">(</span><span class="n">rec_two</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="n">dict_two</span><span class="p">),</span>
<span class="p">]:</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="o">-</span> <span class="n">window</span><span class="p">):</span>
        <span class="n">section</span> <span class="o">=</span> <span class="n">seq</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">window</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">section_dict</span><span class="p">[</span><span class="n">section</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">section_dict</span><span class="p">[</span><span class="n">section</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="c1"># Now find any sub-sequences found in both sequences</span>
<span class="n">matches</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">dict_one</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">dict_two</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%i</span><span class="s2"> unique matches&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches</span><span class="p">))</span>
</pre></div>
</div>
<p>In order to use the <code class="docutils literal notranslate"><span class="pre">pylab.scatter()</span></code> we need separate lists for the
<span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> coordinates:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create lists of x and y coordinates for scatter plot</span>
<span class="n">x</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">y</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">section</span> <span class="ow">in</span> <span class="n">matches</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dict_one</span><span class="p">[</span><span class="n">section</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">dict_two</span><span class="p">[</span><span class="n">section</span><span class="p">]:</span>
            <span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
</pre></div>
</div>
<p>We are now ready to draw the revised dot plot as a scatter plot:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pylab</span>

<span class="n">pylab</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>  <span class="c1"># clear any prior graph</span>
<span class="n">pylab</span><span class="o">.</span><span class="n">gray</span><span class="p">()</span>
<span class="n">pylab</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="n">pylab</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">rec_one</span><span class="p">)</span> <span class="o">-</span> <span class="n">window</span><span class="p">)</span>
<span class="n">pylab</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">rec_two</span><span class="p">)</span> <span class="o">-</span> <span class="n">window</span><span class="p">)</span>
<span class="n">pylab</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> (length </span><span class="si">%i</span><span class="s2"> bp)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">rec_one</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">rec_one</span><span class="p">)))</span>
<span class="n">pylab</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> (length </span><span class="si">%i</span><span class="s2"> bp)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">rec_two</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">rec_two</span><span class="p">)))</span>
<span class="n">pylab</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Dot plot using window size </span><span class="si">%i</span><span class="se">\n</span><span class="s2">(allowing no mis-matches)&quot;</span> <span class="o">%</span> <span class="n">window</span><span class="p">)</span>
<span class="n">pylab</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>That should pop up a new window showing the graph in
<a class="reference internal" href="#fig-nuc-dot-plot-scatter"><span class="std std-numref">Fig. 25</span></a>.</p>
<figure class="align-default" id="fig-nuc-dot-plot-scatter">
<a class="reference internal image-reference" href="../_images/dot_plot_scatter.png"><img alt="Nucleotide dot plot of two orchid sequences using scatter." src="../_images/dot_plot_scatter.png" style="width: 80.0%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 25 </span><span class="caption-text">Nucleotide dot plot of two orchid sequence using  scatter.</span><a class="headerlink" href="#fig-nuc-dot-plot-scatter" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>Personally I find this second plot much easier to read! Again note that
we have <em>not</em> checked for reverse complement matches here – you could
extend this example to do this, and perhaps plot the forward matches in
one color and the reverse matches in another.</p>
</section>
<section id="plotting-the-quality-scores-of-sequencing-read-data">
<h3>Plotting the quality scores of sequencing read data<a class="headerlink" href="#plotting-the-quality-scores-of-sequencing-read-data" title="Link to this heading"></a></h3>
<p>If you are working with second generation sequencing data, you may want
to try plotting the quality data. Here is an example using two FASTQ
files containing paired end reads, <code class="docutils literal notranslate"><span class="pre">SRR001666_1.fastq</span></code> for the forward
reads, and <code class="docutils literal notranslate"><span class="pre">SRR001666_2.fastq</span></code> for the reverse reads. These were
downloaded from the ENA sequence read archive FTP site
(<a class="reference external" href="ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR001/SRR001666/SRR001666_1.fastq.gz">ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR001/SRR001666/SRR001666_1.fastq.gz</a>
and
<a class="reference external" href="ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR001/SRR001666/SRR001666_2.fastq.gz">ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR001/SRR001666/SRR001666_2.fastq.gz</a>),
and are from <em>E. coli</em> – see
<a class="reference external" href="https://www.ebi.ac.uk/ena/data/view/SRR001666">https://www.ebi.ac.uk/ena/data/view/SRR001666</a> for details.</p>
<p>In the following code the <code class="docutils literal notranslate"><span class="pre">pylab.subplot(...)</span></code> function is used in
order to show the forward and reverse qualities on two subplots, side by
side. There is also a little bit of code to only plot the first fifty
reads.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pylab</span>
<span class="kn">from</span> <span class="nn">Bio</span> <span class="kn">import</span> <span class="n">SeqIO</span>

<span class="k">for</span> <span class="n">subfigure</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]:</span>
    <span class="n">filename</span> <span class="o">=</span> <span class="s2">&quot;SRR001666_</span><span class="si">%i</span><span class="s2">.fastq&quot;</span> <span class="o">%</span> <span class="n">subfigure</span>
    <span class="n">pylab</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">subfigure</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">record</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">SeqIO</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;fastq&quot;</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">50</span><span class="p">:</span>
            <span class="k">break</span>  <span class="c1"># trick!</span>
        <span class="n">pylab</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">record</span><span class="o">.</span><span class="n">letter_annotations</span><span class="p">[</span><span class="s2">&quot;phred_quality&quot;</span><span class="p">])</span>
    <span class="n">pylab</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">45</span><span class="p">)</span>
    <span class="n">pylab</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;PHRED quality score&quot;</span><span class="p">)</span>
    <span class="n">pylab</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Position&quot;</span><span class="p">)</span>
<span class="n">pylab</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s2">&quot;SRR001666.png&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Done&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>You should note that we are using the <code class="docutils literal notranslate"><span class="pre">Bio.SeqIO</span></code> format name
<code class="docutils literal notranslate"><span class="pre">fastq</span></code> here because the NCBI has saved these reads using the standard
Sanger FASTQ format with PHRED scores. However, as you might guess from
the read lengths, this data was from an Illumina Genome Analyzer and was
probably originally in one of the two Solexa/Illumina FASTQ variant file
formats instead.</p>
<p>This example uses the <code class="docutils literal notranslate"><span class="pre">pylab.savefig(...)</span></code> function instead of
<code class="docutils literal notranslate"><span class="pre">pylab.show(...)</span></code>, but as mentioned before both are useful.</p>
<figure class="align-default" id="fig-paired-end-qual-plot">
<a class="reference internal image-reference" href="../_images/SRR001666.png"><img alt="Quality plot for some paired end reads." src="../_images/SRR001666.png" style="width: 80.0%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 26 </span><span class="caption-text">Quality plot for some paired end reads.</span><a class="headerlink" href="#fig-paired-end-qual-plot" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>The result is shown in <a class="reference internal" href="#fig-paired-end-qual-plot"><span class="std std-numref">Fig. 26</span></a>.</p>
</section>
</section>
<section id="biosql-storing-sequences-in-a-relational-database">
<span id="sec-biosql"></span><h2>BioSQL – storing sequences in a relational database<a class="headerlink" href="#biosql-storing-sequences-in-a-relational-database" title="Link to this heading"></a></h2>
<p><a class="reference external" href="https://www.biosql.org/">BioSQL</a> is a joint effort between the
<a class="reference external" href="https://www.open-bio.org/wiki/Main_Page">OBF</a> projects (BioPerl,
BioJava etc) to support a shared database schema for storing sequence
data. In theory, you could load a GenBank file into the database with
BioPerl, then using Biopython extract this from the database as a record
object with features - and get more or less the same thing as if you had
loaded the GenBank file directly as a SeqRecord using <code class="docutils literal notranslate"><span class="pre">Bio.SeqIO</span></code>
(Chapter <a class="reference internal" href="chapter_seqio.html#chapter-seqio"><span class="std std-ref">Sequence Input/Output</span></a>).</p>
<p>Biopython’s BioSQL module is currently documented at
<a class="reference external" href="http://biopython.org/wiki/BioSQL">http://biopython.org/wiki/BioSQL</a> which is part of our wiki pages.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="chapter_phenotype.html" class="btn btn-neutral float-left" title="Bio.phenotype: analyze phenotypic data" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="chapter_testing.html" class="btn btn-neutral float-right" title="The Biopython testing framework" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 1999-2024, The Biopython Contributors. See the Biopython license terms.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  


  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      Biopython v: 1.84.dev0
      <span class="fa fa-caret-down"></span>
    </span>
    <div class="rst-other-versions">
      <dl>
        <dt>Versions</dt>
        
          <dd><a href="/docs/1.83/">Previous</a></dd>
        
          <dd><a href="/docs/latest/">Latest</a></dd>
        
          <dd><a href="/docs/dev/">Develop</a></dd>
        
      </dl>
      <dl>
        <dt>Biopython Project</dt>
          <dd>
            <a href="https://biopython.org" class="icon icon-home">  Homepage</a>
          </dd>
          <dd>
            <a href="https://github.com/biopython/biopython" class="fa fa-github">  On GitHub</a>
          </dd>
      </dl>
    </div>
  </div>
<script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>