<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Going 3D: The PDB module &mdash; Biopython 1.84.dev0 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/biopython.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Bio.PopGen: Population genetics" href="chapter_popgen.html" />
    <link rel="prev" title="Swiss-Prot and ExPASy" href="chapter_uniprot.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #10100F" >

          
          
          <a href="../index.html">
            
              <img src="../_static/biopython_logo.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Table of contents</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Biopython Tutorial &amp; Cookbook</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="chapter_introduction.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="chapter_quick_start.html">Quick Start – What can you do with Biopython?</a></li>
<li class="toctree-l2"><a class="reference internal" href="chapter_seq_objects.html">Sequence objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="chapter_seq_annot.html">Sequence annotation objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="chapter_seqio.html">Sequence Input/Output</a></li>
<li class="toctree-l2"><a class="reference internal" href="chapter_align.html">Sequence alignments</a></li>
<li class="toctree-l2"><a class="reference internal" href="chapter_pairwise.html">Pairwise sequence alignment</a></li>
<li class="toctree-l2"><a class="reference internal" href="chapter_msa.html">Multiple Sequence Alignment objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="chapter_pairwise2.html">Pairwise alignments using pairwise2</a></li>
<li class="toctree-l2"><a class="reference internal" href="chapter_blast.html">BLAST (new)</a></li>
<li class="toctree-l2"><a class="reference internal" href="chapter_blast.html#blast-old">BLAST (old)</a></li>
<li class="toctree-l2"><a class="reference internal" href="chapter_searchio.html">BLAST and other sequence search tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="chapter_entrez.html">Accessing NCBI’s Entrez databases</a></li>
<li class="toctree-l2"><a class="reference internal" href="chapter_uniprot.html">Swiss-Prot and ExPASy</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Going 3D: The PDB module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#reading-and-writing-crystal-structure-files">Reading and writing crystal structure files</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#reading-an-mmcif-file">Reading an mmCIF file</a></li>
<li class="toctree-l4"><a class="reference internal" href="#reading-files-in-the-mmtf-format">Reading files in the MMTF format</a></li>
<li class="toctree-l4"><a class="reference internal" href="#reading-a-pdb-file">Reading a PDB file</a></li>
<li class="toctree-l4"><a class="reference internal" href="#reading-a-pqr-file">Reading a PQR file</a></li>
<li class="toctree-l4"><a class="reference internal" href="#reading-files-in-the-pdb-xml-format">Reading files in the PDB XML format</a></li>
<li class="toctree-l4"><a class="reference internal" href="#writing-mmcif-files">Writing mmCIF files</a></li>
<li class="toctree-l4"><a class="reference internal" href="#writing-pdb-files">Writing PDB files</a></li>
<li class="toctree-l4"><a class="reference internal" href="#writing-pqr-files">Writing PQR files</a></li>
<li class="toctree-l4"><a class="reference internal" href="#writing-mmtf-files">Writing MMTF files</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#structure-representation">Structure representation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#structure">Structure</a></li>
<li class="toctree-l4"><a class="reference internal" href="#model">Model</a></li>
<li class="toctree-l4"><a class="reference internal" href="#chain">Chain</a></li>
<li class="toctree-l4"><a class="reference internal" href="#residue">Residue</a></li>
<li class="toctree-l4"><a class="reference internal" href="#atom">Atom</a></li>
<li class="toctree-l4"><a class="reference internal" href="#extracting-a-specific-atom-residue-chain-model-from-a-structure">Extracting a specific <code class="docutils literal notranslate"><span class="pre">Atom/Residue/Chain/Model</span></code> from a Structure</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#disorder">Disorder</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#general-approach">General approach</a></li>
<li class="toctree-l4"><a class="reference internal" href="#disordered-atoms">Disordered atoms</a></li>
<li class="toctree-l4"><a class="reference internal" href="#disordered-residues">Disordered residues</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#hetero-residues">Hetero residues</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#associated-problems">Associated problems</a></li>
<li class="toctree-l4"><a class="reference internal" href="#water-residues">Water residues</a></li>
<li class="toctree-l4"><a class="reference internal" href="#other-hetero-residues">Other hetero residues</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#navigating-through-a-structure-object">Navigating through a Structure object</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#parse-a-pdb-file-and-extract-some-model-chain-residue-and-atom-objects">Parse a PDB file, and extract some Model, Chain, Residue and Atom objects</a></li>
<li class="toctree-l4"><a class="reference internal" href="#iterating-through-all-atoms-of-a-structure">Iterating through all atoms of a structure</a></li>
<li class="toctree-l4"><a class="reference internal" href="#iterating-over-all-residues-of-a-model">Iterating over all residues of a model</a></li>
<li class="toctree-l4"><a class="reference internal" href="#extract-hetero-residue-from-chain-e-g-glucose-glc-moiety-with-resseq-10">Extract hetero residue from chain (e.g. glucose (GLC) moiety with resseq 10)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#print-all-hetero-residues-in-chain">Print all hetero residues in chain</a></li>
<li class="toctree-l4"><a class="reference internal" href="#print-out-coordinates-of-all-ca-atoms-in-structure-with-b-factor-over-50">Print out coordinates of all CA atoms in structure with B factor over 50</a></li>
<li class="toctree-l4"><a class="reference internal" href="#print-out-all-the-residues-that-contain-disordered-atoms">Print out all the residues that contain disordered atoms</a></li>
<li class="toctree-l4"><a class="reference internal" href="#loop-over-all-disordered-atoms-and-select-all-atoms-with-altloc-a-if-present">Loop over all disordered atoms, and select all atoms with altloc A (if present)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#extracting-polypeptides-from-a-structure-object">Extracting polypeptides from a <code class="docutils literal notranslate"><span class="pre">Structure</span></code> object</a></li>
<li class="toctree-l4"><a class="reference internal" href="#obtaining-the-sequence-of-a-structure">Obtaining the sequence of a structure</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#analyzing-structures">Analyzing structures</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#measuring-distances">Measuring distances</a></li>
<li class="toctree-l4"><a class="reference internal" href="#measuring-angles">Measuring angles</a></li>
<li class="toctree-l4"><a class="reference internal" href="#measuring-torsion-angles">Measuring torsion angles</a></li>
<li class="toctree-l4"><a class="reference internal" href="#internal-coordinates-distances-angles-torsion-angles-distance-plots-etc">Internal coordinates - distances, angles, torsion angles, distance plots, etc</a></li>
<li class="toctree-l4"><a class="reference internal" href="#determining-atom-atom-contacts">Determining atom-atom contacts</a></li>
<li class="toctree-l4"><a class="reference internal" href="#superimposing-two-structures">Superimposing two structures</a></li>
<li class="toctree-l4"><a class="reference internal" href="#mapping-the-residues-of-two-related-structures-onto-each-other">Mapping the residues of two related structures onto each other</a></li>
<li class="toctree-l4"><a class="reference internal" href="#calculating-the-half-sphere-exposure">Calculating the Half Sphere Exposure</a></li>
<li class="toctree-l4"><a class="reference internal" href="#determining-the-secondary-structure">Determining the secondary structure</a></li>
<li class="toctree-l4"><a class="reference internal" href="#calculating-the-residue-depth">Calculating the residue depth</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#common-problems-in-pdb-files">Common problems in PDB files</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#examples">Examples</a></li>
<li class="toctree-l4"><a class="reference internal" href="#automatic-correction">Automatic correction</a></li>
<li class="toctree-l4"><a class="reference internal" href="#fatal-errors">Fatal errors</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#accessing-the-protein-data-bank">Accessing the Protein Data Bank</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#downloading-structures-from-the-protein-data-bank">Downloading structures from the Protein Data Bank</a></li>
<li class="toctree-l4"><a class="reference internal" href="#downloading-the-entire-pdb">Downloading the entire PDB</a></li>
<li class="toctree-l4"><a class="reference internal" href="#keeping-a-local-copy-of-the-pdb-up-to-date">Keeping a local copy of the PDB up to date</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#general-questions">General questions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#how-well-tested-is-bio-pdb">How well tested is Bio.PDB?</a></li>
<li class="toctree-l4"><a class="reference internal" href="#how-fast-is-it">How fast is it?</a></li>
<li class="toctree-l4"><a class="reference internal" href="#is-there-support-for-molecular-graphics">Is there support for molecular graphics?</a></li>
<li class="toctree-l4"><a class="reference internal" href="#whos-using-bio-pdb">Who’s using Bio.PDB?</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="chapter_popgen.html">Bio.PopGen: Population genetics</a></li>
<li class="toctree-l2"><a class="reference internal" href="chapter_phylo.html">Phylogenetics with Bio.Phylo</a></li>
<li class="toctree-l2"><a class="reference internal" href="chapter_motifs.html">Sequence motif analysis using Bio.motifs</a></li>
<li class="toctree-l2"><a class="reference internal" href="chapter_cluster.html">Cluster analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="chapter_graphics.html">Graphics including GenomeDiagram</a></li>
<li class="toctree-l2"><a class="reference internal" href="chapter_kegg.html">KEGG</a></li>
<li class="toctree-l2"><a class="reference internal" href="chapter_phenotype.html">Bio.phenotype: analyze phenotypic data</a></li>
<li class="toctree-l2"><a class="reference internal" href="chapter_cookbook.html">Cookbook – Cool things to do with it</a></li>
<li class="toctree-l2"><a class="reference internal" href="chapter_testing.html">The Biopython testing framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="chapter_contributing.html">Where to go from here – contributing to Biopython</a></li>
<li class="toctree-l2"><a class="reference internal" href="chapter_appendix.html">Appendix: Useful stuff about Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="chapter_bibliography.html">Bibliography</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../api/index.html">API documentation</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #10100F" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Biopython</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Biopython Tutorial &amp; Cookbook</a></li>
      <li class="breadcrumb-item active">Going 3D: The PDB module</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/biopython/biopython/blob/master/Doc/Tutorial/chapter_pdb.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul><div class="rst-breadcrumbs-buttons" role="navigation" aria-label="Sequential page navigation">
        <a href="chapter_uniprot.html" class="btn btn-neutral float-left" title="Swiss-Prot and ExPASy" accesskey="p"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="chapter_popgen.html" class="btn btn-neutral float-right" title="Bio.PopGen: Population genetics" accesskey="n">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
  </div>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="going-3d-the-pdb-module">
<span id="chapter-pdb"></span><h1>Going 3D: The PDB module<a class="headerlink" href="#going-3d-the-pdb-module" title="Permalink to this headline"></a></h1>
<p>Bio.PDB is a Biopython module that focuses on working with crystal
structures of biological macromolecules. Among other things, Bio.PDB
includes a PDBParser class that produces a Structure object, which can
be used to access the atomic data in the file in a convenient manner.
There is limited support for parsing the information contained in the
PDB header. PDB file format is no longer being modified or extended to
support new content and PDBx/mmCIF became the standard PDB archive
format in 2014. All the Worldwide Protein Data Bank (wwPDB) sites uses
the macromolecular Crystallographic Information File (mmCIF) data
dictionaries to describe the information content of PDB entries. mmCIF
uses a flexible and extensible key-value pair format for representing
macromolecular structural data and imposes no limitations for the number
of atoms, residues or chains that can be represented in a single PDB
entry (no split entries!).</p>
<section id="reading-and-writing-crystal-structure-files">
<h2>Reading and writing crystal structure files<a class="headerlink" href="#reading-and-writing-crystal-structure-files" title="Permalink to this headline"></a></h2>
<section id="reading-an-mmcif-file">
<h3>Reading an mmCIF file<a class="headerlink" href="#reading-an-mmcif-file" title="Permalink to this headline"></a></h3>
<p>First create an <code class="docutils literal notranslate"><span class="pre">MMCIFParser</span></code> object:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.PDB.MMCIFParser</span> <span class="kn">import</span> <span class="n">MMCIFParser</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">MMCIFParser</span><span class="p">()</span>
</pre></div>
</div>
<p>Then use this parser to create a structure object from the mmCIF file:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">structure</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">get_structure</span><span class="p">(</span><span class="s2">&quot;1fat&quot;</span><span class="p">,</span> <span class="s2">&quot;1fat.cif&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>To have some more low level access to an mmCIF file, you can use the
<code class="docutils literal notranslate"><span class="pre">MMCIF2Dict</span></code> class to create a Python dictionary that maps all mmCIF
tags in an mmCIF file to their values. Whether there are multiple values
(like in the case of tag <code class="docutils literal notranslate"><span class="pre">_atom_site.Cartn_y</span></code>, which holds the
<span class="math notranslate nohighlight">\(y\)</span> coordinates of all atoms) or a single value (like the initial
deposition date), the tag is mapped to a list of values. The dictionary
is created from the mmCIF file as follows:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.PDB.MMCIF2Dict</span> <span class="kn">import</span> <span class="n">MMCIF2Dict</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mmcif_dict</span> <span class="o">=</span> <span class="n">MMCIF2Dict</span><span class="p">(</span><span class="s2">&quot;1FAT.cif&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Example: get the solvent content from an mmCIF file:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span> <span class="o">=</span> <span class="n">mmcif_dict</span><span class="p">[</span><span class="s2">&quot;_exptl_crystal.density_percent_sol&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>Example: get the list of the <span class="math notranslate nohighlight">\(y\)</span> coordinates of all atoms</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y_list</span> <span class="o">=</span> <span class="n">mmcif_dict</span><span class="p">[</span><span class="s2">&quot;_atom_site.Cartn_y&quot;</span><span class="p">]</span>
</pre></div>
</div>
</section>
<section id="reading-files-in-the-mmtf-format">
<h3>Reading files in the MMTF format<a class="headerlink" href="#reading-files-in-the-mmtf-format" title="Permalink to this headline"></a></h3>
<p>You can use the direct MMTFParser to read a structure from a file:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.PDB.mmtf</span> <span class="kn">import</span> <span class="n">MMTFParser</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">structure</span> <span class="o">=</span> <span class="n">MMTFParser</span><span class="o">.</span><span class="n">get_structure</span><span class="p">(</span><span class="s2">&quot;PDB/4CUP.mmtf&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Or you can use the same class to get a structure by its PDB ID:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">structure</span> <span class="o">=</span> <span class="n">MMTFParser</span><span class="o">.</span><span class="n">get_structure_from_url</span><span class="p">(</span><span class="s2">&quot;4CUP&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>This gives you a Structure object as if read from a PDB or mmCIF file.</p>
<p>You can also have access to the underlying data using the external MMTF
library which Biopython is using internally:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mmtf</span> <span class="kn">import</span> <span class="n">fetch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decoded_data</span> <span class="o">=</span> <span class="n">fetch</span><span class="p">(</span><span class="s2">&quot;4CUP&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>For example you can access just the X-coordinate.</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">decoded_data</span><span class="o">.</span><span class="n">x_coord_list</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="reading-a-pdb-file">
<h3>Reading a PDB file<a class="headerlink" href="#reading-a-pdb-file" title="Permalink to this headline"></a></h3>
<p>First we create a <code class="docutils literal notranslate"><span class="pre">PDBParser</span></code> object:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.PDB.PDBParser</span> <span class="kn">import</span> <span class="n">PDBParser</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">PDBParser</span><span class="p">(</span><span class="n">PERMISSIVE</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">PERMISSIVE</span></code> flag indicates that a number of common problems (see
<a class="reference internal" href="#sec-problem-structures"><span class="std std-ref">Examples</span></a>) associated with PDB files will be
ignored (but note that some atoms and/or residues will be missing). If
the flag is not present a <code class="docutils literal notranslate"><span class="pre">PDBConstructionException</span></code> will be generated
if any problems are detected during the parse operation.</p>
<p>The Structure object is then produced by letting the <code class="docutils literal notranslate"><span class="pre">PDBParser</span></code>
object parse a PDB file (the PDB file in this case is called
<code class="docutils literal notranslate"><span class="pre">pdb1fat.ent</span></code>, <code class="docutils literal notranslate"><span class="pre">1fat</span></code> is a user defined name for the structure):</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">structure_id</span> <span class="o">=</span> <span class="s2">&quot;1fat&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filename</span> <span class="o">=</span> <span class="s2">&quot;pdb1fat.ent&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">structure</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">get_structure</span><span class="p">(</span><span class="n">structure_id</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
</pre></div>
</div>
<p>You can extract the header and trailer (simple lists of strings) of the
PDB file from the PDBParser object with the <code class="docutils literal notranslate"><span class="pre">get_header</span></code> and
<code class="docutils literal notranslate"><span class="pre">get_trailer</span></code> methods. Note however that many PDB files contain
headers with incomplete or erroneous information. Many of the errors
have been fixed in the equivalent mmCIF files. <em>Hence, if you are
interested in the header information, it is a good idea to extract
information from mmCIF files using the</em> <em>``MMCIF2Dict``</em> <em>tool described
above, instead of parsing the PDB header.</em></p>
<p>Now that is clarified, let’s return to parsing the PDB header. The
structure object has an attribute called <code class="docutils literal notranslate"><span class="pre">header</span></code> which is a Python
dictionary that maps header records to their values.</p>
<p>Example:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">resolution</span> <span class="o">=</span> <span class="n">structure</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s2">&quot;resolution&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">keywords</span> <span class="o">=</span> <span class="n">structure</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s2">&quot;keywords&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>The available keys are <code class="docutils literal notranslate"><span class="pre">name</span></code>, <code class="docutils literal notranslate"><span class="pre">head</span></code>, <code class="docutils literal notranslate"><span class="pre">deposition_date</span></code>,
<code class="docutils literal notranslate"><span class="pre">release_date</span></code>, <code class="docutils literal notranslate"><span class="pre">structure_method</span></code>, <code class="docutils literal notranslate"><span class="pre">resolution</span></code>,
<code class="docutils literal notranslate"><span class="pre">structure_reference</span></code> (which maps to a list of references),
<code class="docutils literal notranslate"><span class="pre">journal_reference</span></code>, <code class="docutils literal notranslate"><span class="pre">author</span></code>, <code class="docutils literal notranslate"><span class="pre">compound</span></code> (which maps to a
dictionary with various information about the crystallized compound),
<code class="docutils literal notranslate"><span class="pre">has_missing_residues</span></code>, <code class="docutils literal notranslate"><span class="pre">missing_residues</span></code>, and <code class="docutils literal notranslate"><span class="pre">astral</span></code> (which
maps to dictionary with additional information about the domain if
present).</p>
<p><code class="docutils literal notranslate"><span class="pre">has_missing_residues</span></code> maps to a bool that is True if at least one
non-empty <code class="docutils literal notranslate"><span class="pre">REMARK</span> <span class="pre">465</span></code> header line was found. In this case you should
assume that the molecule used in the experiment has some residues for
which no ATOM coordinates could be determined. <code class="docutils literal notranslate"><span class="pre">missing_residues</span></code> maps
to a list of dictionaries with information about the missing residues.
<em>The list of missing residues will be empty or incomplete if the PDB
header does not follow the template from the PDB specification.</em></p>
<p>The dictionary can also be created without creating a <code class="docutils literal notranslate"><span class="pre">Structure</span></code>
object, ie. directly from the PDB file:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.PDB</span> <span class="kn">import</span> <span class="n">parse_pdb_header</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">handle</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">header_dict</span> <span class="o">=</span> <span class="n">parse_pdb_header</span><span class="p">(</span><span class="n">handle</span><span class="p">)</span>
<span class="gp">...</span>
</pre></div>
</div>
</section>
<section id="reading-a-pqr-file">
<h3>Reading a PQR file<a class="headerlink" href="#reading-a-pqr-file" title="Permalink to this headline"></a></h3>
<p>In order to parse a PQR file, proceed in a similar manner as in the case
of PDB files:</p>
<p>Create a <code class="docutils literal notranslate"><span class="pre">PDBParser</span></code> object, using the <code class="docutils literal notranslate"><span class="pre">is_pqr</span></code> flag:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.PDB.PDBParser</span> <span class="kn">import</span> <span class="n">PDBParser</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pqr_parser</span> <span class="o">=</span> <span class="n">PDBParser</span><span class="p">(</span><span class="n">PERMISSIVE</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">is_pqr</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">is_pqr</span></code> flag set to <code class="docutils literal notranslate"><span class="pre">True</span></code> indicates that the file to be parsed
is a PQR file, and that the parser should read the atomic charge and
radius fields for each atom entry. Following the same procedure as for
PQR files, a Structure object is then produced, and the PQR file is
parsed.</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">structure_id</span> <span class="o">=</span> <span class="s2">&quot;1fat&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filename</span> <span class="o">=</span> <span class="s2">&quot;pdb1fat.ent&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">structure</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">get_structure</span><span class="p">(</span><span class="n">structure_id</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">is_pqr</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="reading-files-in-the-pdb-xml-format">
<h3>Reading files in the PDB XML format<a class="headerlink" href="#reading-files-in-the-pdb-xml-format" title="Permalink to this headline"></a></h3>
<p>That’s not yet supported, but we are definitely planning to support that
in the future (it’s not a lot of work). Contact the Biopython developers
via the mailing list if you need this.</p>
</section>
<section id="writing-mmcif-files">
<h3>Writing mmCIF files<a class="headerlink" href="#writing-mmcif-files" title="Permalink to this headline"></a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">MMCIFIO</span></code> class can be used to write structures to the mmCIF file
format:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">io</span> <span class="o">=</span> <span class="n">MMCIFIO</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">io</span><span class="o">.</span><span class="n">set_structure</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">io</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s2">&quot;out.cif&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">Select</span></code> class can be used in a similar way to <code class="docutils literal notranslate"><span class="pre">PDBIO</span></code> below.
mmCIF dictionaries read using <code class="docutils literal notranslate"><span class="pre">MMCIF2Dict</span></code> can also be written:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">io</span> <span class="o">=</span> <span class="n">MMCIFIO</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">io</span><span class="o">.</span><span class="n">set_dict</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">io</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s2">&quot;out.cif&quot;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="writing-pdb-files">
<h3>Writing PDB files<a class="headerlink" href="#writing-pdb-files" title="Permalink to this headline"></a></h3>
<p>Use the <code class="docutils literal notranslate"><span class="pre">PDBIO</span></code> class for this. It’s easy to write out specific parts
of a structure too, of course.</p>
<p>Example: saving a structure</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">io</span> <span class="o">=</span> <span class="n">PDBIO</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">io</span><span class="o">.</span><span class="n">set_structure</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">io</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s2">&quot;out.pdb&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>If you want to write out a part of the structure, make use of the
<code class="docutils literal notranslate"><span class="pre">Select</span></code> class (also in <code class="docutils literal notranslate"><span class="pre">PDBIO</span></code>). Select has four methods:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">accept_model(model)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">accept_chain(chain)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">accept_residue(residue)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">accept_atom(atom)</span></code></p></li>
</ul>
<p>By default, every method returns 1 (which means the
model/chain/residue/atom is included in the output). By subclassing
<code class="docutils literal notranslate"><span class="pre">Select</span></code> and returning 0 when appropriate you can exclude models,
chains, etc. from the output. Cumbersome maybe, but very powerful. The
following code only writes out glycine residues:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">GlySelect</span><span class="p">(</span><span class="n">Select</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">accept_residue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">residue</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">if</span> <span class="n">residue</span><span class="o">.</span><span class="n">get_name</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;GLY&quot;</span><span class="p">:</span>
<span class="gp">... </span>            <span class="k">return</span> <span class="kc">True</span>
<span class="gp">... </span>        <span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>            <span class="k">return</span> <span class="kc">False</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">io</span> <span class="o">=</span> <span class="n">PDBIO</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">io</span><span class="o">.</span><span class="n">set_structure</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">io</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s2">&quot;gly_only.pdb&quot;</span><span class="p">,</span> <span class="n">GlySelect</span><span class="p">())</span>
</pre></div>
</div>
<p>If this is all too complicated for you, the <code class="docutils literal notranslate"><span class="pre">Dice</span></code> module contains a
handy <code class="docutils literal notranslate"><span class="pre">extract</span></code> function that writes out all residues in a chain
between a start and end residue.</p>
</section>
<section id="writing-pqr-files">
<h3>Writing PQR files<a class="headerlink" href="#writing-pqr-files" title="Permalink to this headline"></a></h3>
<p>Use the <code class="docutils literal notranslate"><span class="pre">PDBIO</span></code> class as you would for a PDB file, with the flag
<code class="docutils literal notranslate"><span class="pre">is_pqr=True</span></code>. The PDBIO methods can be used in the case of PQR files
as well.</p>
<p>Example: writing a PQR file</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">io</span> <span class="o">=</span> <span class="n">PDBIO</span><span class="p">(</span><span class="n">is_pqr</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">io</span><span class="o">.</span><span class="n">set_structure</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">io</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s2">&quot;out.pdb&quot;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="writing-mmtf-files">
<h3>Writing MMTF files<a class="headerlink" href="#writing-mmtf-files" title="Permalink to this headline"></a></h3>
<p>To write structures to the MMTF file format:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.PDB.mmtf</span> <span class="kn">import</span> <span class="n">MMTFIO</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">io</span> <span class="o">=</span> <span class="n">MMTFIO</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">io</span><span class="o">.</span><span class="n">set_structure</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">io</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s2">&quot;out.mmtf&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">Select</span></code> class can be used as above. Note that the bonding
information, secondary structure assignment and some other information
contained in standard MMTF files is not written out as it is not easy to
determine from the structure object. In addition, molecules that are
grouped into the same entity in standard MMTF files are treated as
separate entities by <code class="docutils literal notranslate"><span class="pre">MMTFIO</span></code>.</p>
</section>
</section>
<section id="structure-representation">
<h2>Structure representation<a class="headerlink" href="#structure-representation" title="Permalink to this headline"></a></h2>
<p>The overall layout of a <code class="docutils literal notranslate"><span class="pre">Structure</span></code> object follows the so-called SMCRA
(Structure/Model/Chain/Residue/Atom) architecture:</p>
<ul class="simple">
<li><p>A structure consists of models</p></li>
<li><p>A model consists of chains</p></li>
<li><p>A chain consists of residues</p></li>
<li><p>A residue consists of atoms</p></li>
</ul>
<p>This is the way many structural biologists/bioinformaticians think about
structure, and provides a simple but efficient way to deal with
structure. Additional stuff is essentially added when needed. A UML
diagram of the <code class="docutils literal notranslate"><span class="pre">Structure</span></code> object (forget about the <code class="docutils literal notranslate"><span class="pre">Disordered</span></code>
classes for now) is shown in <a class="reference internal" href="#fig-smcra"><span class="std std-numref">Fig. 3</span></a>. Such a data
structure is not necessarily best suited for the representation of the
macromolecular content of a structure, but it is absolutely necessary
for a good interpretation of the data present in a file that describes
the structure (typically a PDB or MMCIF file). If this hierarchy cannot
represent the contents of a structure file, it is fairly certain that
the file contains an error or at least does not describe the structure
unambiguously. If a SMCRA data structure cannot be generated, there is
reason to suspect a problem. Parsing a PDB file can thus be used to
detect likely problems. We will give several examples of this in section
<a class="reference internal" href="#sec-problem-structures"><span class="std std-ref">Examples</span></a>.</p>
<figure class="align-default" id="fig-smcra">
<a class="reference internal image-reference" href="../_images/smcra.png"><img alt="UML diagram of SMCRA architecture of the ``Structure`` class" src="../_images/smcra.png" style="width: 80.0%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 3 </span><span class="caption-text">UML diagram of SMCRA architecture of the <code class="docutils literal notranslate"><span class="pre">Structure</span></code> class.</span><a class="headerlink" href="#fig-smcra" title="Permalink to this image"></a></p>
<div class="legend">
<p>This is used to represent a macromolecular structure. Full lines with
diamonds denote aggregation, full lines with arrows denote referencing,
full lines with triangles denote inheritance and dashed lines with
triangles denote interface realization.</p>
</div>
</figcaption>
</figure>
<p>Structure, Model, Chain and Residue are all subclasses of the Entity
base class. The Atom class only (partly) implements the Entity interface
(because an Atom does not have children).</p>
<p>For each Entity subclass, you can extract a child by using a unique id
for that child as a key (e.g. you can extract an Atom object from a
Residue object by using an atom name string as a key, you can extract a
Chain object from a Model object by using its chain identifier as a
key).</p>
<p>Disordered atoms and residues are represented by DisorderedAtom and
DisorderedResidue classes, which are both subclasses of the
DisorderedEntityWrapper base class. They hide the complexity associated
with disorder and behave exactly as Atom and Residue objects.</p>
<p>In general, a child Entity object (i.e. Atom, Residue, Chain, Model) can
be extracted from its parent (i.e. Residue, Chain, Model, Structure,
respectively) by using an id as a key.</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">child_entity</span> <span class="o">=</span> <span class="n">parent_entity</span><span class="p">[</span><span class="n">child_id</span><span class="p">]</span>
</pre></div>
</div>
<p>You can also get a list of all child Entities of a parent Entity object.
Note that this list is sorted in a specific way (e.g. according to chain
identifier for Chain objects in a Model object).</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">child_list</span> <span class="o">=</span> <span class="n">parent_entity</span><span class="o">.</span><span class="n">get_list</span><span class="p">()</span>
</pre></div>
</div>
<p>You can also get the parent from a child:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parent_entity</span> <span class="o">=</span> <span class="n">child_entity</span><span class="o">.</span><span class="n">get_parent</span><span class="p">()</span>
</pre></div>
</div>
<p>At all levels of the SMCRA hierarchy, you can also extract a <em>full id</em>.
The full id is a tuple containing all id’s starting from the top object
(Structure) down to the current object. A full id for a Residue object
e.g. is something like:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">full_id</span> <span class="o">=</span> <span class="n">residue</span><span class="o">.</span><span class="n">get_full_id</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">full_id</span><span class="p">)</span>
<span class="go">(&quot;1abc&quot;, 0, &quot;A&quot;, (&quot;&quot;, 10, &quot;A&quot;))</span>
</pre></div>
</div>
<p>This corresponds to:</p>
<ul class="simple">
<li><p>The Structure with id <code class="docutils literal notranslate"><span class="pre">&quot;1abc&quot;</span></code></p></li>
<li><p>The Model with id <code class="docutils literal notranslate"><span class="pre">0</span></code></p></li>
<li><p>The Chain with id <code class="docutils literal notranslate"><span class="pre">&quot;A&quot;</span></code></p></li>
<li><p>The Residue with id <code class="docutils literal notranslate"><span class="pre">(&quot;&quot;,</span> <span class="pre">10,</span> <span class="pre">&quot;A&quot;)</span></code></p></li>
</ul>
<p>The Residue id indicates that the residue is not a hetero-residue (nor a
water) because it has a blank hetero field, that its sequence identifier
is 10 and that its insertion code is <code class="docutils literal notranslate"><span class="pre">&quot;A&quot;</span></code>.</p>
<p>To get the entity’s id, use the <code class="docutils literal notranslate"><span class="pre">get_id</span></code> method:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">entity</span><span class="o">.</span><span class="n">get_id</span><span class="p">()</span>
</pre></div>
</div>
<p>You can check if the entity has a child with a given id by using the
<code class="docutils literal notranslate"><span class="pre">has_id</span></code> method:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">entity</span><span class="o">.</span><span class="n">has_id</span><span class="p">(</span><span class="n">entity_id</span><span class="p">)</span>
</pre></div>
</div>
<p>The length of an entity is equal to its number of children:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">nr_children</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">entity</span><span class="p">)</span>
</pre></div>
</div>
<p>It is possible to delete, rename, add, etc. child entities from a parent
entity, but this does not include any sanity checks (e.g. it is possible
to add two residues with the same id to one chain). This really should
be done via a nice Decorator class that includes integrity checking, but
you can take a look at the code (Entity.py) if you want to use the raw
interface.</p>
<section id="structure">
<h3>Structure<a class="headerlink" href="#structure" title="Permalink to this headline"></a></h3>
<p>The Structure object is at the top of the hierarchy. Its id is a user
given string. The Structure contains a number of Model children. Most
crystal structures (but not all) contain a single model, while NMR
structures typically consist of several models. Disorder in crystal
structures of large parts of molecules can also result in several
models.</p>
</section>
<section id="model">
<h3>Model<a class="headerlink" href="#model" title="Permalink to this headline"></a></h3>
<p>The id of the Model object is an integer, which is derived from the
position of the model in the parsed file (they are automatically
numbered starting from 0). Crystal structures generally have only one
model (with id 0), while NMR files usually have several models. Whereas
many PDB parsers assume that there is only one model, the <code class="docutils literal notranslate"><span class="pre">Structure</span></code>
class in <code class="docutils literal notranslate"><span class="pre">Bio.PDB</span></code> is designed such that it can easily handle PDB
files with more than one model.</p>
<p>As an example, to get the first model from a Structure object, use</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">first_model</span> <span class="o">=</span> <span class="n">structure</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>The Model object stores a list of Chain children.</p>
</section>
<section id="chain">
<h3>Chain<a class="headerlink" href="#chain" title="Permalink to this headline"></a></h3>
<p>The id of a Chain object is derived from the chain identifier in the
PDB/mmCIF file, and is a single character (typically a letter). Each
Chain in a Model object has a unique id. As an example, to get the Chain
object with identifier “A” from a Model object, use</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">chain_A</span> <span class="o">=</span> <span class="n">model</span><span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>The Chain object stores a list of Residue children.</p>
</section>
<section id="residue">
<h3>Residue<a class="headerlink" href="#residue" title="Permalink to this headline"></a></h3>
<p>A residue id is a tuple with three elements:</p>
<ul>
<li><p>The <strong>hetero-field</strong> (hetfield): this is</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'W'</span></code> in the case of a water molecule;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'H_'</span></code> followed by the residue name for other hetero residues
(e.g. <code class="docutils literal notranslate"><span class="pre">'H_GLC'</span></code> in the case of a glucose molecule);</p></li>
<li><p>blank for standard amino and nucleic acids.</p></li>
</ul>
<p>This scheme is adopted for reasons described in section
<a class="reference internal" href="#sec-hetero-problems"><span class="std std-ref">Associated problems</span></a>.</p>
</li>
<li><p>The <strong>sequence identifier</strong> (resseq), an integer describing the
position of the residue in the chain (e.g., 100);</p></li>
<li><p>The <strong>insertion code</strong> (icode); a string, e.g. ’A’. The insertion
code is sometimes used to preserve a certain desirable residue
numbering scheme. A Ser 80 insertion mutant (inserted e.g. between a
Thr 80 and an Asn 81 residue) could e.g. have sequence identifiers
and insertion codes as follows: Thr 80 A, Ser 80 B, Asn 81. In this
way the residue numbering scheme stays in tune with that of the wild
type structure.</p></li>
</ul>
<p>The id of the above glucose residue would thus be
<code class="docutils literal notranslate"><span class="pre">(’H_GLC’,</span> <span class="pre">100,</span> <span class="pre">’A’)</span></code>. If the hetero-flag and insertion code are
blank, the sequence identifier alone can be used:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="go"># Full id</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">residue</span> <span class="o">=</span> <span class="n">chain</span><span class="p">[(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="p">)]</span>
<span class="go"># Shortcut id</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">residue</span> <span class="o">=</span> <span class="n">chain</span><span class="p">[</span><span class="mi">100</span><span class="p">]</span>
</pre></div>
</div>
<p>The reason for the hetero-flag is that many, many PDB files use the same
sequence identifier for an amino acid and a hetero-residue or a water,
which would create obvious problems if the hetero-flag was not used.</p>
<p>Unsurprisingly, a Residue object stores a set of Atom children. It also
contains a string that specifies the residue name (e.g. “ASN”) and the
segment identifier of the residue (well known to X-PLOR users, but not
used in the construction of the SMCRA data structure).</p>
<p>Let’s look at some examples. Asn 10 with a blank insertion code would
have residue id <code class="docutils literal notranslate"><span class="pre">(’</span> <span class="pre">’,</span> <span class="pre">10,</span> <span class="pre">’</span> <span class="pre">’)</span></code>. Water 10 would have residue id
<code class="docutils literal notranslate"><span class="pre">(’W’,</span> <span class="pre">10,</span> <span class="pre">’</span> <span class="pre">’)</span></code>. A glucose molecule (a hetero residue with residue
name GLC) with sequence identifier 10 would have residue id
<code class="docutils literal notranslate"><span class="pre">(’H_GLC’,</span> <span class="pre">10,</span> <span class="pre">’</span> <span class="pre">’)</span></code>. In this way, the three residues (with the same
insertion code and sequence identifier) can be part of the same chain
because their residue id’s are distinct.</p>
<p>In most cases, the hetflag and insertion code fields will be blank, e.g.
<code class="docutils literal notranslate"><span class="pre">(’</span> <span class="pre">’,</span> <span class="pre">10,</span> <span class="pre">’</span> <span class="pre">’)</span></code>. In these cases, the sequence identifier can be used
as a shortcut for the full id:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="go"># use full id</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res10</span> <span class="o">=</span> <span class="n">chain</span><span class="p">[(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="p">)]</span>
<span class="go"># use shortcut</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res10</span> <span class="o">=</span> <span class="n">chain</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span>
</pre></div>
</div>
<p>Each Residue object in a Chain object should have a unique id. However,
disordered residues are dealt with in a special way, as described in
section <a class="reference internal" href="#sec-point-mutations"><span class="std std-ref">Point mutations</span></a>.</p>
<p>A Residue object has a number of additional methods:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">residue</span><span class="o">.</span><span class="n">get_resname</span><span class="p">()</span>  <span class="c1"># returns the residue name, e.g. &quot;ASN&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">residue</span><span class="o">.</span><span class="n">is_disordered</span><span class="p">()</span>  <span class="c1"># returns 1 if the residue has disordered atoms</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">residue</span><span class="o">.</span><span class="n">get_segid</span><span class="p">()</span>  <span class="c1"># returns the SEGID, e.g. &quot;CHN1&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">residue</span><span class="o">.</span><span class="n">has_id</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>  <span class="c1"># test if a residue has a certain atom</span>
</pre></div>
</div>
<p>You can use <code class="docutils literal notranslate"><span class="pre">is_aa(residue)</span></code> to test if a Residue object is an amino
acid.</p>
</section>
<section id="atom">
<h3>Atom<a class="headerlink" href="#atom" title="Permalink to this headline"></a></h3>
<p>The Atom object stores the data associated with an atom, and has no
children. The id of an atom is its atom name (e.g. “OG” for the side
chain oxygen of a Ser residue). An Atom id needs to be unique in a
Residue. Again, an exception is made for disordered atoms, as described
in section <a class="reference internal" href="#sec-disordered-atoms"><span class="std std-ref">Disordered atoms</span></a>.</p>
<p>The atom id is simply the atom name (eg. <code class="docutils literal notranslate"><span class="pre">’CA’</span></code>). In practice, the
atom name is created by stripping all spaces from the atom name in the
PDB file.</p>
<p>However, in PDB files, a space can be part of an atom name. Often,
calcium atoms are called <code class="docutils literal notranslate"><span class="pre">’CA..’</span></code> in order to distinguish them from
C<span class="math notranslate nohighlight">\(\alpha\)</span> atoms (which are called <code class="docutils literal notranslate"><span class="pre">’.CA.’</span></code>). In cases were
stripping the spaces would create problems (ie. two atoms called
<code class="docutils literal notranslate"><span class="pre">’CA’</span></code> in the same residue) the spaces are kept.</p>
<p>In a PDB file, an atom name consists of 4 chars, typically with leading
and trailing spaces. Often these spaces can be removed for ease of use
(e.g. an amino acid C<span class="math notranslate nohighlight">\(\alpha\)</span> atom is labeled “.CA.” in a PDB
file, where the dots represent spaces). To generate an atom name (and
thus an atom id) the spaces are removed, unless this would result in a
name collision in a Residue (i.e. two Atom objects with the same atom
name and id). In the latter case, the atom name including spaces is
tried. This situation can e.g. happen when one residue contains atoms
with names “.CA.” and “CA..”, although this is not very likely.</p>
<p>The atomic data stored includes the atom name, the atomic coordinates
(including standard deviation if present), the B factor (including
anisotropic B factors and standard deviation if present), the altloc
specifier and the full atom name including spaces. Less used items like
the atom element number or the atomic charge sometimes specified in a
PDB file are not stored.</p>
<p>To manipulate the atomic coordinates, use the <code class="docutils literal notranslate"><span class="pre">transform</span></code> method of
the <code class="docutils literal notranslate"><span class="pre">Atom</span></code> object. Use the <code class="docutils literal notranslate"><span class="pre">set_coord</span></code> method to specify the atomic
coordinates directly.</p>
<p>An Atom object has the following additional methods:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">get_name</span><span class="p">()</span>  <span class="c1"># atom name (spaces stripped, e.g. &quot;CA&quot;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">get_id</span><span class="p">()</span>  <span class="c1"># id (equals atom name)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">get_coord</span><span class="p">()</span>  <span class="c1"># atomic coordinates</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">get_vector</span><span class="p">()</span>  <span class="c1"># atomic coordinates as Vector object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">get_bfactor</span><span class="p">()</span>  <span class="c1"># isotropic B factor</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">get_occupancy</span><span class="p">()</span>  <span class="c1"># occupancy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">get_altloc</span><span class="p">()</span>  <span class="c1"># alternative location specifier</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">get_sigatm</span><span class="p">()</span>  <span class="c1"># standard deviation of atomic parameters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">get_siguij</span><span class="p">()</span>  <span class="c1"># standard deviation of anisotropic B factor</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">get_anisou</span><span class="p">()</span>  <span class="c1"># anisotropic B factor</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">get_fullname</span><span class="p">()</span>  <span class="c1"># atom name (with spaces, e.g. &quot;.CA.&quot;)</span>
</pre></div>
</div>
<p>To represent the atom coordinates, siguij, anisotropic B factor and
sigatm Numpy arrays are used.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">get_vector</span></code> method returns a <code class="docutils literal notranslate"><span class="pre">Vector</span></code> object representation of
the coordinates of the <code class="docutils literal notranslate"><span class="pre">Atom</span></code> object, allowing you to do vector
operations on atomic coordinates. <code class="docutils literal notranslate"><span class="pre">Vector</span></code> implements the full set of
3D vector operations, matrix multiplication (left and right) and some
advanced rotation-related operations as well.</p>
<p>As an example of the capabilities of Bio.PDB’s <code class="docutils literal notranslate"><span class="pre">Vector</span></code> module,
suppose that you would like to find the position of a Gly residue’s
C<span class="math notranslate nohighlight">\(\beta\)</span> atom, if it had one. Rotating the N atom of the Gly
residue along the C<span class="math notranslate nohighlight">\(\alpha\)</span>-C bond over -120 degrees roughly
puts it in the position of a virtual C<span class="math notranslate nohighlight">\(\beta\)</span> atom. Here’s how
to do it, making use of the <code class="docutils literal notranslate"><span class="pre">rotaxis</span></code> method (which can be used to
construct a rotation around a certain axis) of the <code class="docutils literal notranslate"><span class="pre">Vector</span></code> module:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="go"># get atom coordinates as vectors</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">residue</span><span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">get_vector</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">residue</span><span class="p">[</span><span class="s2">&quot;C&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">get_vector</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ca</span> <span class="o">=</span> <span class="n">residue</span><span class="p">[</span><span class="s2">&quot;CA&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">get_vector</span><span class="p">()</span>
<span class="go"># center at origin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">ca</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">c</span> <span class="o">-</span> <span class="n">ca</span>
<span class="go"># find rotation matrix that rotates n</span>
<span class="go"># -120 degrees along the ca-c vector</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rot</span> <span class="o">=</span> <span class="n">rotaxis</span><span class="p">(</span><span class="o">-</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">120.0</span> <span class="o">/</span> <span class="mf">180.0</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="go"># apply rotation to ca-n vector</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cb_at_origin</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">left_multiply</span><span class="p">(</span><span class="n">rot</span><span class="p">)</span>
<span class="go"># put on top of ca atom</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cb</span> <span class="o">=</span> <span class="n">cb_at_origin</span> <span class="o">+</span> <span class="n">ca</span>
</pre></div>
</div>
<p>This example shows that it’s possible to do some quite nontrivial vector
operations on atomic data, which can be quite useful. In addition to all
the usual vector operations (cross (use <code class="docutils literal notranslate"><span class="pre">*</span></code><code class="docutils literal notranslate"><span class="pre">*</span></code>), and dot (use
<code class="docutils literal notranslate"><span class="pre">*</span></code>) product, angle, norm, etc.) and the above mentioned <code class="docutils literal notranslate"><span class="pre">rotaxis</span></code>
function, the <code class="docutils literal notranslate"><span class="pre">Vector</span></code> module also has methods to rotate (<code class="docutils literal notranslate"><span class="pre">rotmat</span></code>)
or reflect (<code class="docutils literal notranslate"><span class="pre">refmat</span></code>) one vector on top of another.</p>
</section>
<section id="extracting-a-specific-atom-residue-chain-model-from-a-structure">
<h3>Extracting a specific <code class="docutils literal notranslate"><span class="pre">Atom/Residue/Chain/Model</span></code> from a Structure<a class="headerlink" href="#extracting-a-specific-atom-residue-chain-model-from-a-structure" title="Permalink to this headline"></a></h3>
<p>These are some examples:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">structure</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chain</span> <span class="o">=</span> <span class="n">model</span><span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">residue</span> <span class="o">=</span> <span class="n">chain</span><span class="p">[</span><span class="mi">100</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atom</span> <span class="o">=</span> <span class="n">residue</span><span class="p">[</span><span class="s2">&quot;CA&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>Note that you can use a shortcut:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">atom</span> <span class="o">=</span> <span class="n">structure</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;A&quot;</span><span class="p">][</span><span class="mi">100</span><span class="p">][</span><span class="s2">&quot;CA&quot;</span><span class="p">]</span>
</pre></div>
</div>
</section>
</section>
<section id="disorder">
<h2>Disorder<a class="headerlink" href="#disorder" title="Permalink to this headline"></a></h2>
<p>Bio.PDB can handle both disordered atoms and point mutations (i.e. a Gly
and an Ala residue in the same position).</p>
<section id="general-approach">
<span id="sec-disorder-problems"></span><h3>General approach<a class="headerlink" href="#general-approach" title="Permalink to this headline"></a></h3>
<p>Disorder should be dealt with from two points of view: the atom and the
residue points of view. In general, we have tried to encapsulate all the
complexity that arises from disorder. If you just want to loop over all
C<span class="math notranslate nohighlight">\(\alpha\)</span> atoms, you do not care that some residues have a
disordered side chain. On the other hand it should also be possible to
represent disorder completely in the data structure. Therefore,
disordered atoms or residues are stored in special objects that behave
as if there is no disorder. This is done by only representing a subset
of the disordered atoms or residues. Which subset is picked (e.g. which
of the two disordered OG side chain atom positions of a Ser residue is
used) can be specified by the user.</p>
</section>
<section id="disordered-atoms">
<span id="sec-disordered-atoms"></span><h3>Disordered atoms<a class="headerlink" href="#disordered-atoms" title="Permalink to this headline"></a></h3>
<p>Disordered atoms are represented by ordinary <code class="docutils literal notranslate"><span class="pre">Atom</span></code> objects, but all
<code class="docutils literal notranslate"><span class="pre">Atom</span></code> objects that represent the same physical atom are stored in a
<code class="docutils literal notranslate"><span class="pre">DisorderedAtom</span></code> object (see <a class="reference internal" href="#fig-smcra"><span class="std std-numref">Fig. 3</span></a>). Each
<code class="docutils literal notranslate"><span class="pre">Atom</span></code> object in a <code class="docutils literal notranslate"><span class="pre">DisorderedAtom</span></code> object can be uniquely indexed
using its altloc specifier. The <code class="docutils literal notranslate"><span class="pre">DisorderedAtom</span></code> object forwards all
uncaught method calls to the selected Atom object, by default the one
that represents the atom with the highest occupancy. The user can of
course change the selected <code class="docutils literal notranslate"><span class="pre">Atom</span></code> object, making use of its altloc
specifier. In this way atom disorder is represented correctly without
much additional complexity. In other words, if you are not interested in
atom disorder, you will not be bothered by it.</p>
<p>Each disordered atom has a characteristic altloc identifier. You can
specify that a <code class="docutils literal notranslate"><span class="pre">DisorderedAtom</span></code> object should behave like the <code class="docutils literal notranslate"><span class="pre">Atom</span></code>
object associated with a specific altloc identifier:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">atom</span><span class="o">.</span><span class="n">disordered_select</span><span class="p">(</span><span class="s2">&quot;A&quot;</span><span class="p">)</span>  <span class="c1"># select altloc A atom</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">get_altloc</span><span class="p">())</span>
<span class="go">&quot;A&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atom</span><span class="o">.</span><span class="n">disordered_select</span><span class="p">(</span><span class="s2">&quot;B&quot;</span><span class="p">)</span>  <span class="c1"># select altloc B atom</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">get_altloc</span><span class="p">())</span>
<span class="go">&quot;B&quot;</span>
</pre></div>
</div>
</section>
<section id="disordered-residues">
<h3>Disordered residues<a class="headerlink" href="#disordered-residues" title="Permalink to this headline"></a></h3>
<section id="common-case">
<h4>Common case<a class="headerlink" href="#common-case" title="Permalink to this headline"></a></h4>
<p>The most common case is a residue that contains one or more disordered
atoms. This is evidently solved by using DisorderedAtom objects to
represent the disordered atoms, and storing the DisorderedAtom object in
a Residue object just like ordinary Atom objects. The DisorderedAtom
will behave exactly like an ordinary atom (in fact the atom with the
highest occupancy) by forwarding all uncaught method calls to one of the
Atom objects (the selected Atom object) it contains.</p>
</section>
<section id="point-mutations">
<span id="sec-point-mutations"></span><h4>Point mutations<a class="headerlink" href="#point-mutations" title="Permalink to this headline"></a></h4>
<p>A special case arises when disorder is due to a point mutation, i.e.
when two or more point mutants of a polypeptide are present in the
crystal. An example of this can be found in PDB structure 1EN2.</p>
<p>Since these residues belong to a different residue type (e.g. let’s say
Ser 60 and Cys 60) they should not be stored in a single <code class="docutils literal notranslate"><span class="pre">Residue</span></code>
object as in the common case. In this case, each residue is represented
by one <code class="docutils literal notranslate"><span class="pre">Residue</span></code> object, and both <code class="docutils literal notranslate"><span class="pre">Residue</span></code> objects are stored in a
single <code class="docutils literal notranslate"><span class="pre">DisorderedResidue</span></code> object (see <a class="reference internal" href="#fig-smcra"><span class="std std-numref">Fig. 3</span></a>).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">DisorderedResidue</span></code> object forwards all uncaught methods to the
selected <code class="docutils literal notranslate"><span class="pre">Residue</span></code> object (by default the last <code class="docutils literal notranslate"><span class="pre">Residue</span></code> object
added), and thus behaves like an ordinary residue. Each <code class="docutils literal notranslate"><span class="pre">Residue</span></code>
object in a <code class="docutils literal notranslate"><span class="pre">DisorderedResidue</span></code> object can be uniquely identified by
its residue name. In the above example, residue Ser 60 would have id
“SER” in the <code class="docutils literal notranslate"><span class="pre">DisorderedResidue</span></code> object, while residue Cys 60 would
have id “CYS”. The user can select the active <code class="docutils literal notranslate"><span class="pre">Residue</span></code> object in a
<code class="docutils literal notranslate"><span class="pre">DisorderedResidue</span></code> object via this id.</p>
<p>Example: suppose that a chain has a point mutation at position 10,
consisting of a Ser and a Cys residue. Make sure that residue 10 of this
chain behaves as the Cys residue.</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">residue</span> <span class="o">=</span> <span class="n">chain</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">residue</span><span class="o">.</span><span class="n">disordered_select</span><span class="p">(</span><span class="s2">&quot;CYS&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>In addition, you can get a list of all <code class="docutils literal notranslate"><span class="pre">Atom</span></code> objects (ie. all
<code class="docutils literal notranslate"><span class="pre">DisorderedAtom</span></code> objects are ’unpacked’ to their individual <code class="docutils literal notranslate"><span class="pre">Atom</span></code>
objects) using the <code class="docutils literal notranslate"><span class="pre">get_unpacked_list</span></code> method of a
<code class="docutils literal notranslate"><span class="pre">(Disordered)Residue</span></code> object.</p>
</section>
</section>
</section>
<section id="hetero-residues">
<h2>Hetero residues<a class="headerlink" href="#hetero-residues" title="Permalink to this headline"></a></h2>
<section id="associated-problems">
<span id="sec-hetero-problems"></span><h3>Associated problems<a class="headerlink" href="#associated-problems" title="Permalink to this headline"></a></h3>
<p>A common problem with hetero residues is that several hetero and
non-hetero residues present in the same chain share the same sequence
identifier (and insertion code). Therefore, to generate a unique id for
each hetero residue, waters and other hetero residues are treated in a
different way.</p>
<p>Remember that Residue object have the tuple (hetfield, resseq, icode) as
id. The hetfield is blank (“ ”) for amino and nucleic acids, and a
string for waters and other hetero residues. The content of the hetfield
is explained below.</p>
</section>
<section id="water-residues">
<h3>Water residues<a class="headerlink" href="#water-residues" title="Permalink to this headline"></a></h3>
<p>The hetfield string of a water residue consists of the letter “W”. So a
typical residue id for a water is (“W”, 1, “ ”).</p>
</section>
<section id="other-hetero-residues">
<h3>Other hetero residues<a class="headerlink" href="#other-hetero-residues" title="Permalink to this headline"></a></h3>
<p>The hetfield string for other hetero residues starts with “H_” followed
by the residue name. A glucose molecule e.g. with residue name “GLC”
would have hetfield “H_GLC”. Its residue id could e.g. be (“H_GLC”, 1, “
”).</p>
</section>
</section>
<section id="navigating-through-a-structure-object">
<h2>Navigating through a Structure object<a class="headerlink" href="#navigating-through-a-structure-object" title="Permalink to this headline"></a></h2>
<section id="parse-a-pdb-file-and-extract-some-model-chain-residue-and-atom-objects">
<h3>Parse a PDB file, and extract some Model, Chain, Residue and Atom objects<a class="headerlink" href="#parse-a-pdb-file-and-extract-some-model-chain-residue-and-atom-objects" title="Permalink to this headline"></a></h3>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.PDB.PDBParser</span> <span class="kn">import</span> <span class="n">PDBParser</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">PDBParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">structure</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">get_structure</span><span class="p">(</span><span class="s2">&quot;test&quot;</span><span class="p">,</span> <span class="s2">&quot;1fat.pdb&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">structure</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chain</span> <span class="o">=</span> <span class="n">model</span><span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">residue</span> <span class="o">=</span> <span class="n">chain</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atom</span> <span class="o">=</span> <span class="n">residue</span><span class="p">[</span><span class="s2">&quot;CA&quot;</span><span class="p">]</span>
</pre></div>
</div>
</section>
<section id="iterating-through-all-atoms-of-a-structure">
<h3>Iterating through all atoms of a structure<a class="headerlink" href="#iterating-through-all-atoms-of-a-structure" title="Permalink to this headline"></a></h3>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">PDBParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">structure</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">get_structure</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="s2">&quot;pdb1fat.ent&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">structure</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">chain</span> <span class="ow">in</span> <span class="n">model</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">for</span> <span class="n">residue</span> <span class="ow">in</span> <span class="n">chain</span><span class="p">:</span>
<span class="gp">... </span>            <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">residue</span><span class="p">:</span>
<span class="gp">... </span>                <span class="nb">print</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>There is a shortcut if you want to iterate over all atoms in a
structure:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">atoms</span> <span class="o">=</span> <span class="n">structure</span><span class="o">.</span><span class="n">get_atoms</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>Similarly, to iterate over all atoms in a chain, use</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">atoms</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">get_atoms</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
<span class="gp">...</span>
</pre></div>
</div>
</section>
<section id="iterating-over-all-residues-of-a-model">
<h3>Iterating over all residues of a model<a class="headerlink" href="#iterating-over-all-residues-of-a-model" title="Permalink to this headline"></a></h3>
<p>or if you want to iterate over all residues in a model:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">residues</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">get_residues</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">residue</span> <span class="ow">in</span> <span class="n">residues</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">residue</span><span class="p">)</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>You can also use the <code class="docutils literal notranslate"><span class="pre">Selection.unfold_entities</span></code> function to get all
residues from a structure:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res_list</span> <span class="o">=</span> <span class="n">Selection</span><span class="o">.</span><span class="n">unfold_entities</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="s2">&quot;R&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>or to get all atoms from a chain:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">atom_list</span> <span class="o">=</span> <span class="n">Selection</span><span class="o">.</span><span class="n">unfold_entities</span><span class="p">(</span><span class="n">chain</span><span class="p">,</span> <span class="s2">&quot;A&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Obviously, <code class="docutils literal notranslate"><span class="pre">A=atom,</span> <span class="pre">R=residue,</span> <span class="pre">C=chain,</span> <span class="pre">M=model,</span> <span class="pre">S=structure</span></code>. You can
use this to go up in the hierarchy, e.g. to get a list of (unique)
<code class="docutils literal notranslate"><span class="pre">Residue</span></code> or <code class="docutils literal notranslate"><span class="pre">Chain</span></code> parents from a list of <code class="docutils literal notranslate"><span class="pre">Atoms</span></code>:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">residue_list</span> <span class="o">=</span> <span class="n">Selection</span><span class="o">.</span><span class="n">unfold_entities</span><span class="p">(</span><span class="n">atom_list</span><span class="p">,</span> <span class="s2">&quot;R&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chain_list</span> <span class="o">=</span> <span class="n">Selection</span><span class="o">.</span><span class="n">unfold_entities</span><span class="p">(</span><span class="n">atom_list</span><span class="p">,</span> <span class="s2">&quot;C&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>For more info, see the API documentation.</p>
</section>
<section id="extract-hetero-residue-from-chain-e-g-glucose-glc-moiety-with-resseq-10">
<h3>Extract hetero residue from chain (e.g. glucose (GLC) moiety with resseq 10)<a class="headerlink" href="#extract-hetero-residue-from-chain-e-g-glucose-glc-moiety-with-resseq-10" title="Permalink to this headline"></a></h3>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">residue_id</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;H_GLC&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">residue</span> <span class="o">=</span> <span class="n">chain</span><span class="p">[</span><span class="n">residue_id</span><span class="p">]</span>
</pre></div>
</div>
</section>
<section id="print-all-hetero-residues-in-chain">
<h3>Print all hetero residues in chain<a class="headerlink" href="#print-all-hetero-residues-in-chain" title="Permalink to this headline"></a></h3>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">residue</span> <span class="ow">in</span> <span class="n">chain</span><span class="o">.</span><span class="n">get_list</span><span class="p">():</span>
<span class="gp">... </span>    <span class="n">residue_id</span> <span class="o">=</span> <span class="n">residue</span><span class="o">.</span><span class="n">get_id</span><span class="p">()</span>
<span class="gp">... </span>    <span class="n">hetfield</span> <span class="o">=</span> <span class="n">residue_id</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">hetfield</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;H&quot;</span><span class="p">:</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="n">residue_id</span><span class="p">)</span>
<span class="gp">...</span>
</pre></div>
</div>
</section>
<section id="print-out-coordinates-of-all-ca-atoms-in-structure-with-b-factor-over-50">
<h3>Print out coordinates of all CA atoms in structure with B factor over 50<a class="headerlink" href="#print-out-coordinates-of-all-ca-atoms-in-structure-with-b-factor-over-50" title="Permalink to this headline"></a></h3>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">structure</span><span class="o">.</span><span class="n">get_list</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">chain</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">get_list</span><span class="p">():</span>
<span class="gp">... </span>        <span class="k">for</span> <span class="n">residue</span> <span class="ow">in</span> <span class="n">chain</span><span class="o">.</span><span class="n">get_list</span><span class="p">():</span>
<span class="gp">... </span>            <span class="k">if</span> <span class="n">residue</span><span class="o">.</span><span class="n">has_id</span><span class="p">(</span><span class="s2">&quot;CA&quot;</span><span class="p">):</span>
<span class="gp">... </span>                <span class="n">ca</span> <span class="o">=</span> <span class="n">residue</span><span class="p">[</span><span class="s2">&quot;CA&quot;</span><span class="p">]</span>
<span class="gp">... </span>                <span class="k">if</span> <span class="n">ca</span><span class="o">.</span><span class="n">get_bfactor</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mf">50.0</span><span class="p">:</span>
<span class="gp">... </span>                    <span class="nb">print</span><span class="p">(</span><span class="n">ca</span><span class="o">.</span><span class="n">get_coord</span><span class="p">())</span>
<span class="gp">...</span>
</pre></div>
</div>
</section>
<section id="print-out-all-the-residues-that-contain-disordered-atoms">
<h3>Print out all the residues that contain disordered atoms<a class="headerlink" href="#print-out-all-the-residues-that-contain-disordered-atoms" title="Permalink to this headline"></a></h3>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">structure</span><span class="o">.</span><span class="n">get_list</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">chain</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">get_list</span><span class="p">():</span>
<span class="gp">... </span>        <span class="k">for</span> <span class="n">residue</span> <span class="ow">in</span> <span class="n">chain</span><span class="o">.</span><span class="n">get_list</span><span class="p">():</span>
<span class="gp">... </span>            <span class="k">if</span> <span class="n">residue</span><span class="o">.</span><span class="n">is_disordered</span><span class="p">():</span>
<span class="gp">... </span>                <span class="n">resseq</span> <span class="o">=</span> <span class="n">residue</span><span class="o">.</span><span class="n">get_id</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">... </span>                <span class="n">resname</span> <span class="o">=</span> <span class="n">residue</span><span class="o">.</span><span class="n">get_resname</span><span class="p">()</span>
<span class="gp">... </span>                <span class="n">model_id</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">get_id</span><span class="p">()</span>
<span class="gp">... </span>                <span class="n">chain_id</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">get_id</span><span class="p">()</span>
<span class="gp">... </span>                <span class="nb">print</span><span class="p">(</span><span class="n">model_id</span><span class="p">,</span> <span class="n">chain_id</span><span class="p">,</span> <span class="n">resname</span><span class="p">,</span> <span class="n">resseq</span><span class="p">)</span>
<span class="gp">...</span>
</pre></div>
</div>
</section>
<section id="loop-over-all-disordered-atoms-and-select-all-atoms-with-altloc-a-if-present">
<h3>Loop over all disordered atoms, and select all atoms with altloc A (if present)<a class="headerlink" href="#loop-over-all-disordered-atoms-and-select-all-atoms-with-altloc-a-if-present" title="Permalink to this headline"></a></h3>
<p>This will make sure that the SMCRA data structure will behave as if only
the atoms with altloc A are present.</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">structure</span><span class="o">.</span><span class="n">get_list</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">chain</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">get_list</span><span class="p">():</span>
<span class="gp">... </span>        <span class="k">for</span> <span class="n">residue</span> <span class="ow">in</span> <span class="n">chain</span><span class="o">.</span><span class="n">get_list</span><span class="p">():</span>
<span class="gp">... </span>            <span class="k">if</span> <span class="n">residue</span><span class="o">.</span><span class="n">is_disordered</span><span class="p">():</span>
<span class="gp">... </span>                <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">residue</span><span class="o">.</span><span class="n">get_list</span><span class="p">():</span>
<span class="gp">... </span>                    <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">is_disordered</span><span class="p">():</span>
<span class="gp">... </span>                        <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">disordered_has_id</span><span class="p">(</span><span class="s2">&quot;A&quot;</span><span class="p">):</span>
<span class="gp">... </span>                            <span class="n">atom</span><span class="o">.</span><span class="n">disordered_select</span><span class="p">(</span><span class="s2">&quot;A&quot;</span><span class="p">)</span>
<span class="gp">...</span>
</pre></div>
</div>
</section>
<section id="extracting-polypeptides-from-a-structure-object">
<h3>Extracting polypeptides from a <code class="docutils literal notranslate"><span class="pre">Structure</span></code> object<a class="headerlink" href="#extracting-polypeptides-from-a-structure-object" title="Permalink to this headline"></a></h3>
<p>To extract polypeptides from a structure, construct a list of
<code class="docutils literal notranslate"><span class="pre">Polypeptide</span></code> objects from a <code class="docutils literal notranslate"><span class="pre">Structure</span></code> object using
<code class="docutils literal notranslate"><span class="pre">PolypeptideBuilder</span></code> as follows:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">model_nr</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">polypeptide_list</span> <span class="o">=</span> <span class="n">build_peptides</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">model_nr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">polypeptide</span> <span class="ow">in</span> <span class="n">polypeptide_list</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">polypeptide</span><span class="p">)</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>A Polypeptide object is simply a UserList of Residue objects, and is
always created from a single Model (in this case model 1). You can use
the resulting <code class="docutils literal notranslate"><span class="pre">Polypeptide</span></code> object to get the sequence as a <code class="docutils literal notranslate"><span class="pre">Seq</span></code>
object or to get a list of C<span class="math notranslate nohighlight">\(\alpha\)</span> atoms as well. Polypeptides
can be built using a C-N or a C<span class="math notranslate nohighlight">\(\alpha\)</span>-C<span class="math notranslate nohighlight">\(\alpha\)</span>
distance criterion.</p>
<p>Example:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="go"># Using C-N</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ppb</span> <span class="o">=</span> <span class="n">PPBuilder</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">pp</span> <span class="ow">in</span> <span class="n">ppb</span><span class="o">.</span><span class="n">build_peptides</span><span class="p">(</span><span class="n">structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">get_sequence</span><span class="p">())</span>
<span class="gp">...</span>
<span class="go"># Using CA-CA</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ppb</span> <span class="o">=</span> <span class="n">CaPPBuilder</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">pp</span> <span class="ow">in</span> <span class="n">ppb</span><span class="o">.</span><span class="n">build_peptides</span><span class="p">(</span><span class="n">structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">get_sequence</span><span class="p">())</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>Note that in the above case only model 0 of the structure is considered
by <code class="docutils literal notranslate"><span class="pre">PolypeptideBuilder</span></code>. However, it is possible to use
<code class="docutils literal notranslate"><span class="pre">PolypeptideBuilder</span></code> to build <code class="docutils literal notranslate"><span class="pre">Polypeptide</span></code> objects from <code class="docutils literal notranslate"><span class="pre">Model</span></code>
and <code class="docutils literal notranslate"><span class="pre">Chain</span></code> objects as well.</p>
</section>
<section id="obtaining-the-sequence-of-a-structure">
<h3>Obtaining the sequence of a structure<a class="headerlink" href="#obtaining-the-sequence-of-a-structure" title="Permalink to this headline"></a></h3>
<p>The first thing to do is to extract all polypeptides from the structure
(as above). The sequence of each polypeptide can then easily be obtained
from the <code class="docutils literal notranslate"><span class="pre">Polypeptide</span></code> objects. The sequence is represented as a
Biopython <code class="docutils literal notranslate"><span class="pre">Seq</span></code> object.</p>
<p>Example:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">seq</span> <span class="o">=</span> <span class="n">polypeptide</span><span class="o">.</span><span class="n">get_sequence</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">seq</span>
<span class="go">Seq(&#39;SNDIYFNFQRFNETNLILQRDASVSSSGQLRLTNLN&#39;)</span>
</pre></div>
</div>
</section>
</section>
<section id="analyzing-structures">
<h2>Analyzing structures<a class="headerlink" href="#analyzing-structures" title="Permalink to this headline"></a></h2>
<section id="measuring-distances">
<h3>Measuring distances<a class="headerlink" href="#measuring-distances" title="Permalink to this headline"></a></h3>
<p>The minus operator for atoms has been overloaded to return the distance
between two atoms.</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="go"># Get some atoms</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ca1</span> <span class="o">=</span> <span class="n">residue1</span><span class="p">[</span><span class="s2">&quot;CA&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ca2</span> <span class="o">=</span> <span class="n">residue2</span><span class="p">[</span><span class="s2">&quot;CA&quot;</span><span class="p">]</span>
<span class="go"># Simply subtract the atoms to get their distance</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">distance</span> <span class="o">=</span> <span class="n">ca1</span> <span class="o">-</span> <span class="n">ca2</span>
</pre></div>
</div>
</section>
<section id="measuring-angles">
<h3>Measuring angles<a class="headerlink" href="#measuring-angles" title="Permalink to this headline"></a></h3>
<p>Use the vector representation of the atomic coordinates, and the
<code class="docutils literal notranslate"><span class="pre">calc_angle</span></code> function from the <code class="docutils literal notranslate"><span class="pre">Vector</span></code> module:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vector1</span> <span class="o">=</span> <span class="n">atom1</span><span class="o">.</span><span class="n">get_vector</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vector2</span> <span class="o">=</span> <span class="n">atom2</span><span class="o">.</span><span class="n">get_vector</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vector3</span> <span class="o">=</span> <span class="n">atom3</span><span class="o">.</span><span class="n">get_vector</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">angle</span> <span class="o">=</span> <span class="n">calc_angle</span><span class="p">(</span><span class="n">vector1</span><span class="p">,</span> <span class="n">vector2</span><span class="p">,</span> <span class="n">vector3</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="measuring-torsion-angles">
<h3>Measuring torsion angles<a class="headerlink" href="#measuring-torsion-angles" title="Permalink to this headline"></a></h3>
<p>Use the vector representation of the atomic coordinates, and the
<code class="docutils literal notranslate"><span class="pre">calc_dihedral</span></code> function from the <code class="docutils literal notranslate"><span class="pre">Vector</span></code> module:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vector1</span> <span class="o">=</span> <span class="n">atom1</span><span class="o">.</span><span class="n">get_vector</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vector2</span> <span class="o">=</span> <span class="n">atom2</span><span class="o">.</span><span class="n">get_vector</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vector3</span> <span class="o">=</span> <span class="n">atom3</span><span class="o">.</span><span class="n">get_vector</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vector4</span> <span class="o">=</span> <span class="n">atom4</span><span class="o">.</span><span class="n">get_vector</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">angle</span> <span class="o">=</span> <span class="n">calc_dihedral</span><span class="p">(</span><span class="n">vector1</span><span class="p">,</span> <span class="n">vector2</span><span class="p">,</span> <span class="n">vector3</span><span class="p">,</span> <span class="n">vector4</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="internal-coordinates-distances-angles-torsion-angles-distance-plots-etc">
<span id="sec-internal-coordinates"></span><h3>Internal coordinates - distances, angles, torsion angles, distance plots, etc<a class="headerlink" href="#internal-coordinates-distances-angles-torsion-angles-distance-plots-etc" title="Permalink to this headline"></a></h3>
<p>Protein structures are normally supplied in 3D XYZ coordinates relative
to a fixed origin, as in a PDB or mmCIF file. The <code class="docutils literal notranslate"><span class="pre">internal_coords</span></code>
module facilitates converting this system to and from bond lengths,
angles and dihedral angles. In addition to supporting standard <em>psi,
phi, chi</em>, etc. calculations on protein structures, this representation
is invariant to translation and rotation, and the implementation exposes
multiple benefits for structure analysis.</p>
<p>First load up some modules here for later examples:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.PDB.PDBParser</span> <span class="kn">import</span> <span class="n">PDBParser</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.PDB.Chain</span> <span class="kn">import</span> <span class="n">Chain</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.PDB.internal_coords</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.PDB.PICIO</span> <span class="kn">import</span> <span class="n">write_PIC</span><span class="p">,</span> <span class="n">read_PIC</span><span class="p">,</span> <span class="n">read_PIC_seq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.PDB.ic_rebuild</span> <span class="kn">import</span> <span class="n">write_PDB</span><span class="p">,</span> <span class="n">IC_duplicate</span><span class="p">,</span> <span class="n">structure_rebuild_test</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.PDB.SCADIO</span> <span class="kn">import</span> <span class="n">write_SCAD</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.Seq</span> <span class="kn">import</span> <span class="n">Seq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.SeqRecord</span> <span class="kn">import</span> <span class="n">SeqRecord</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.PDB.PDBIO</span> <span class="kn">import</span> <span class="n">PDBIO</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</pre></div>
</div>
<section id="accessing-dihedrals-angles-and-bond-lengths">
<h4>Accessing dihedrals, angles and bond lengths<a class="headerlink" href="#accessing-dihedrals-angles-and-bond-lengths" title="Permalink to this headline"></a></h4>
<p>We start with the simple case of computing internal coordinates for a
structure:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># load a structure as normal, get first chain</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">PDBParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">myProtein</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">get_structure</span><span class="p">(</span><span class="s2">&quot;1a8o&quot;</span><span class="p">,</span> <span class="s2">&quot;1A8O.pdb&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">myChain</span> <span class="o">=</span> <span class="n">myProtein</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;A&quot;</span><span class="p">]</span>
</pre></div>
</div>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># compute bond lengths, angles, dihedral angles</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">myChain</span><span class="o">.</span><span class="n">atom_to_internal_coordinates</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">chain break at THR  186  due to MaxPeptideBond (1.4 angstroms) exceeded</span>
<span class="go">chain break at THR  216  due to MaxPeptideBond (1.4 angstroms) exceeded</span>
</pre></div>
</div>
<p>The chain break warnings for 1A8O are suppressed by removing the
<code class="docutils literal notranslate"><span class="pre">verbose=True</span></code> option above. To avoid the creation of a break and
instead allow unrealistically long N-C bonds, override the class
variable <code class="docutils literal notranslate"><span class="pre">MaxPeptideBond</span></code>, e.g.:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">IC_Chain</span><span class="o">.</span><span class="n">MaxPeptideBond</span> <span class="o">=</span> <span class="mf">4.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">myChain</span><span class="o">.</span><span class="n">internal_coord</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># force re-loading structure data with new cutoff</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">myChain</span><span class="o">.</span><span class="n">atom_to_internal_coordinates</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>At this point the values are available at both the chain and residue
level. The first residue of 1A8O is HETATM MSE (selenomethionine), so we
investigate residue 2 below using either canonical names or atom
specifiers. Here we obtain the <em>chi1</em> dihedral and <em>tau</em> angles by name
and by atom sequence, and the C<span class="math notranslate nohighlight">\(\alpha\)</span>-C<span class="math notranslate nohighlight">\(\beta\)</span>
distance by specifying the atom pair:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r2</span> <span class="o">=</span> <span class="n">myChain</span><span class="o">.</span><span class="n">child_list</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r2</span>
<span class="go">&lt;Residue ASP het=  resseq=152 icode= &gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r2ic</span> <span class="o">=</span> <span class="n">r2</span><span class="o">.</span><span class="n">internal_coord</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">r2ic</span><span class="p">,</span> <span class="s2">&quot;:&quot;</span><span class="p">,</span> <span class="n">r2ic</span><span class="o">.</span><span class="n">pretty_str</span><span class="p">(),</span> <span class="s2">&quot;:&quot;</span><span class="p">,</span> <span class="n">r2ic</span><span class="o">.</span><span class="n">rbase</span><span class="p">,</span> <span class="s2">&quot;:&quot;</span><span class="p">,</span> <span class="n">r2ic</span><span class="o">.</span><span class="n">lc</span><span class="p">)</span>
<span class="go">(&#39;1a8o&#39;, 0, &#39;A&#39;, (&#39; &#39;, 152, &#39; &#39;)) : ASP  152  : (152, None, &#39;D&#39;) : D</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r2chi1</span> <span class="o">=</span> <span class="n">r2ic</span><span class="o">.</span><span class="n">get_angle</span><span class="p">(</span><span class="s2">&quot;chi1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">r2chi1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">-144.86</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r2ic</span><span class="o">.</span><span class="n">get_angle</span><span class="p">(</span><span class="s2">&quot;chi1&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="n">r2ic</span><span class="o">.</span><span class="n">get_angle</span><span class="p">(</span><span class="s2">&quot;N:CA:CB:CG&quot;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">r2ic</span><span class="o">.</span><span class="n">get_angle</span><span class="p">(</span><span class="s2">&quot;tau&quot;</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">113.45</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r2ic</span><span class="o">.</span><span class="n">get_angle</span><span class="p">(</span><span class="s2">&quot;tau&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="n">r2ic</span><span class="o">.</span><span class="n">get_angle</span><span class="p">(</span><span class="s2">&quot;N:CA:C&quot;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">r2ic</span><span class="o">.</span><span class="n">get_length</span><span class="p">(</span><span class="s2">&quot;CA:CB&quot;</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">1.53</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">Chain.internal_coord</span></code> object holds arrays and dictionaries of
hedra (3 bonded atoms) and dihedra (4 bonded atoms) objects. The
dictionaries are indexed by tuples of <code class="docutils literal notranslate"><span class="pre">AtomKey</span></code> objects; <code class="docutils literal notranslate"><span class="pre">AtomKey</span></code>
objects capture residue position, insertion code, 1 or 3-character
residue name, atom name, altloc and occupancy.</p>
<p>Below we obtain the same <em>chi1</em> and <em>tau</em> angles as above by indexing
the <code class="docutils literal notranslate"><span class="pre">Chain</span></code> arrays directly, using <code class="docutils literal notranslate"><span class="pre">AtomKey</span></code>s to index the
<code class="docutils literal notranslate"><span class="pre">Chain</span></code> arrays:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">myCic</span> <span class="o">=</span> <span class="n">myChain</span><span class="o">.</span><span class="n">internal_coord</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">r2chi1_object</span> <span class="o">=</span> <span class="n">r2ic</span><span class="o">.</span><span class="n">pick_angle</span><span class="p">(</span><span class="s2">&quot;chi1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># or same thing (as for get_angle() above):</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r2chi1_object</span> <span class="o">==</span> <span class="n">r2ic</span><span class="o">.</span><span class="n">pick_angle</span><span class="p">(</span><span class="s2">&quot;N:CA:CB:CG&quot;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r2chi1_key</span> <span class="o">=</span> <span class="n">r2chi1_object</span><span class="o">.</span><span class="n">atomkeys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r2chi1_key</span>  <span class="c1"># r2chi1_key is tuple of AtomKeys</span>
<span class="go">(152_D_N, 152_D_CA, 152_D_CB, 152_D_CG)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">r2chi1_index</span> <span class="o">=</span> <span class="n">myCic</span><span class="o">.</span><span class="n">dihedraNdx</span><span class="p">[</span><span class="n">r2chi1_key</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># or same thing:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r2chi1_index</span> <span class="o">==</span> <span class="n">r2chi1_object</span><span class="o">.</span><span class="n">ndx</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">myCic</span><span class="o">.</span><span class="n">dihedraAngle</span><span class="p">[</span><span class="n">r2chi1_index</span><span class="p">],</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">-144.86</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># also:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r2chi1_object</span> <span class="o">==</span> <span class="n">myCic</span><span class="o">.</span><span class="n">dihedra</span><span class="p">[</span><span class="n">r2chi1_key</span><span class="p">]</span>
<span class="go">True</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># hedra angles are similar:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r2tau</span> <span class="o">=</span> <span class="n">r2ic</span><span class="o">.</span><span class="n">pick_angle</span><span class="p">(</span><span class="s2">&quot;tau&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">myCic</span><span class="o">.</span><span class="n">hedraAngle</span><span class="p">[</span><span class="n">r2tau</span><span class="o">.</span><span class="n">ndx</span><span class="p">],</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">113.45</span>
</pre></div>
</div>
<p>Obtaining bond length data at the <code class="docutils literal notranslate"><span class="pre">Chain</span></code> level is more complicated
(and not recommended). As shown here, multiple hedra will share a single
bond in different positions:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r2CaCb</span> <span class="o">=</span> <span class="n">r2ic</span><span class="o">.</span><span class="n">pick_length</span><span class="p">(</span><span class="s2">&quot;CA:CB&quot;</span><span class="p">)</span>  <span class="c1"># returns list of hedra containing bond</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r2CaCb</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">atomkeys</span>
<span class="go">(152_D_CB, 152_D_CA, 152_D_C)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">myCic</span><span class="o">.</span><span class="n">hedraL12</span><span class="p">[</span><span class="n">r2CaCb</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ndx</span><span class="p">],</span> <span class="mi">2</span><span class="p">))</span>  <span class="c1"># position 1-2</span>
<span class="go">1.53</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r2CaCb</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">atomkeys</span>
<span class="go">(152_D_N, 152_D_CA, 152_D_CB)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">myCic</span><span class="o">.</span><span class="n">hedraL23</span><span class="p">[</span><span class="n">r2CaCb</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">ndx</span><span class="p">],</span> <span class="mi">2</span><span class="p">))</span>  <span class="c1"># position 2-3</span>
<span class="go">1.53</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r2CaCb</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">atomkeys</span>
<span class="go">(152_D_CA, 152_D_CB, 152_D_CG)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">myCic</span><span class="o">.</span><span class="n">hedraL12</span><span class="p">[</span><span class="n">r2CaCb</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">ndx</span><span class="p">],</span> <span class="mi">2</span><span class="p">))</span>  <span class="c1"># position 1-2</span>
<span class="go">1.53</span>
</pre></div>
</div>
<p>Please use the <code class="docutils literal notranslate"><span class="pre">Residue</span></code> level <code class="docutils literal notranslate"><span class="pre">set_length</span></code>:math:`` function
instead.</p>
</section>
<section id="testing-structures-for-completeness">
<h4>Testing structures for completeness<a class="headerlink" href="#testing-structures-for-completeness" title="Permalink to this headline"></a></h4>
<p>Missing atoms and other issues can cause problems when rebuilding a
structure. Use <code class="docutils literal notranslate"><span class="pre">structure_rebuild_test</span></code>:math:`` to determine quickly
if a structure has sufficient data for a clean rebuild. Add
<code class="docutils literal notranslate"><span class="pre">verbose=True</span></code> and/or inspect the result dictionary for more detail:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># check myChain makes sense (can get angles and rebuild same structure)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">resultDict</span> <span class="o">=</span> <span class="n">structure_rebuild_test</span><span class="p">(</span><span class="n">myChain</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">resultDict</span><span class="p">[</span><span class="s2">&quot;pass&quot;</span><span class="p">]</span>
<span class="go">True</span>
</pre></div>
</div>
</section>
<section id="modifying-and-rebuilding-structures">
<h4>Modifying and rebuilding structures<a class="headerlink" href="#modifying-and-rebuilding-structures" title="Permalink to this headline"></a></h4>
<p>It’s preferable to use the residue level <code class="docutils literal notranslate"><span class="pre">set_angle</span></code>:math:`` and
<code class="docutils literal notranslate"><span class="pre">set_length</span></code>:math:`` facilities for modifying internal coordinates
rather than directly accessing the <code class="docutils literal notranslate"><span class="pre">Chain</span></code> structures. While directly
modifying hedra angles is safe, bond lengths appear in multiple
overlapping hedra as noted above, and this is handled by
<code class="docutils literal notranslate"><span class="pre">set_length</span></code>:math:<code class="docutils literal notranslate"><span class="pre">.</span> <span class="pre">When</span> <span class="pre">applied</span> <span class="pre">to</span> <span class="pre">a</span> <span class="pre">dihedral</span> <span class="pre">angle,</span>
<span class="pre">``set_angle</span></code>:math:`` will wrap the result to +/-180 and rotate
adjacent dihedra as well (such as both bonds for an isoleucine <em>chi1</em>
angle - which is probably what you want).</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># rotate residue 2 chi1 angle by -120 degrees</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r2ic</span><span class="o">.</span><span class="n">set_angle</span><span class="p">(</span><span class="s2">&quot;chi1&quot;</span><span class="p">,</span> <span class="n">r2chi1</span> <span class="o">-</span> <span class="mf">120.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">r2ic</span><span class="o">.</span><span class="n">get_angle</span><span class="p">(</span><span class="s2">&quot;chi1&quot;</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">95.14</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r2ic</span><span class="o">.</span><span class="n">set_length</span><span class="p">(</span><span class="s2">&quot;CA:CB&quot;</span><span class="p">,</span> <span class="mf">1.49</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">myCic</span><span class="o">.</span><span class="n">hedraL12</span><span class="p">[</span><span class="n">r2CaCb</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ndx</span><span class="p">],</span> <span class="mi">2</span><span class="p">))</span>  <span class="c1"># Cb-Ca-C position 1-2</span>
<span class="go">1.49</span>
</pre></div>
</div>
<p>Rebuilding a structure from internal coordinates is a simple call to
<code class="docutils literal notranslate"><span class="pre">internal_to_atom_coordinates()</span></code>:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">myChain</span><span class="o">.</span><span class="n">internal_to_atom_coordinates</span><span class="p">()</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># just for proof:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">myChain</span><span class="o">.</span><span class="n">internal_coord</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># all internal_coord data removed, only atoms left</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">myChain</span><span class="o">.</span><span class="n">atom_to_internal_coordinates</span><span class="p">()</span>  <span class="c1"># re-generate internal coordinates</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r2ic</span> <span class="o">=</span> <span class="n">myChain</span><span class="o">.</span><span class="n">child_list</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">internal_coord</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">r2ic</span><span class="o">.</span><span class="n">get_angle</span><span class="p">(</span><span class="s2">&quot;chi1&quot;</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>  <span class="c1"># show measured values match what was set above</span>
<span class="go">95.14</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">myCic</span><span class="o">.</span><span class="n">hedraL23</span><span class="p">[</span><span class="n">r2CaCb</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">ndx</span><span class="p">],</span> <span class="mi">2</span><span class="p">))</span>  <span class="c1"># N-Ca-Cb position 2-3</span>
<span class="go">1.49</span>
</pre></div>
</div>
<p>The generated structure can be written with PDBIO, as normal:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">write_PDB</span><span class="p">(</span><span class="n">myProtein</span><span class="p">,</span> <span class="s2">&quot;myChain.pdb&quot;</span><span class="p">)</span>
<span class="c1"># or just the ATOM records without headers:</span>
<span class="n">io</span> <span class="o">=</span> <span class="n">PDBIO</span><span class="p">()</span>
<span class="n">io</span><span class="o">.</span><span class="n">set_structure</span><span class="p">(</span><span class="n">myProtein</span><span class="p">)</span>
<span class="n">io</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s2">&quot;myChain2.pdb&quot;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="protein-internal-coordinate-pic-files-and-default-values">
<h4>Protein Internal Coordinate (.pic) files and default values<a class="headerlink" href="#protein-internal-coordinate-pic-files-and-default-values" title="Permalink to this headline"></a></h4>
<p>A file format is defined in the <code class="docutils literal notranslate"><span class="pre">PICIO</span></code> module to describe protein
chains as hedra and dihedra relative to initial coordinates. All parts
of the file other than the residue sequence information (e.g.
<code class="docutils literal notranslate"><span class="pre">(’1A8O’,</span> <span class="pre">0,</span> <span class="pre">’A’,</span> <span class="pre">(’</span> <span class="pre">’,</span> <span class="pre">153,</span> <span class="pre">’</span> <span class="pre">’))</span> <span class="pre">ILE</span></code>) are optional, and will be
filled in with default values if not specified and
<code class="docutils literal notranslate"><span class="pre">read_PIC</span></code>:math:`` is called with the <code class="docutils literal notranslate"><span class="pre">defaults=True</span></code> option.
Default values are calculated from Sep 2019 Dunbrack
cullpdb_pc20_res2.2_R1.0.</p>
<p>Here we write ‘myChain’ as a <code class="docutils literal notranslate"><span class="pre">.pic</span></code> file of internal coordinate
specifications and then read it back in as ‘myProtein2’.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># write chain as &#39;protein internal coordinates&#39; (.pic) file</span>
<span class="n">write_PIC</span><span class="p">(</span><span class="n">myProtein</span><span class="p">,</span> <span class="s2">&quot;myChain.pic&quot;</span><span class="p">)</span>
<span class="c1"># read .pic file</span>
<span class="n">myProtein2</span> <span class="o">=</span> <span class="n">read_PIC</span><span class="p">(</span><span class="s2">&quot;myChain.pic&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>As all internal coordinate values can be replaced with defaults,
<code class="docutils literal notranslate"><span class="pre">PICIO.read_PIC_seq</span></code>:math:`` is supplied as a utility function to
create a valid (mostly helical) default structure from an input
sequence:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># create default structure for random sequence by reading as .pic file</span>
<span class="n">myProtein3</span> <span class="o">=</span> <span class="n">read_PIC_seq</span><span class="p">(</span>
    <span class="n">SeqRecord</span><span class="p">(</span>
        <span class="n">Seq</span><span class="p">(</span><span class="s2">&quot;GAVLIMFPSTCNQYWDEHKR&quot;</span><span class="p">),</span>
        <span class="nb">id</span><span class="o">=</span><span class="s2">&quot;1RND&quot;</span><span class="p">,</span>
        <span class="n">description</span><span class="o">=</span><span class="s2">&quot;my random sequence&quot;</span><span class="p">,</span>
    <span class="p">)</span>
<span class="p">)</span>
<span class="n">myProtein3</span><span class="o">.</span><span class="n">internal_to_atom_coordinates</span><span class="p">()</span>
<span class="n">write_PDB</span><span class="p">(</span><span class="n">myProtein3</span><span class="p">,</span> <span class="s2">&quot;myRandom.pdb&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>It may be of interest to explore the accuracy required in e.g. <em>omega</em>
angles (180.0), hedra angles and/or bond lengths when generating
structures from internal coordinates. The picFlags option to
<code class="docutils literal notranslate"><span class="pre">write_PIC</span></code>:math:`` enables this, allowing the selection of data to
be written to the .pic file vs. left unspecified to get default values.</p>
<p>Various combinations are possible and some presets are supplied, for
example <code class="docutils literal notranslate"><span class="pre">classic</span></code> will write only <em>psi, phi, tau</em>, proline <em>omega</em> and
sidechain <em>chi</em> angles to the .pic file:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">write_PIC</span><span class="p">(</span><span class="n">myProtein</span><span class="p">,</span> <span class="s2">&quot;myChain.pic&quot;</span><span class="p">,</span> <span class="n">picFlags</span><span class="o">=</span><span class="n">IC_Residue</span><span class="o">.</span><span class="n">pic_flags</span><span class="o">.</span><span class="n">classic</span><span class="p">)</span>
<span class="n">myProtein2</span> <span class="o">=</span> <span class="n">read_PIC</span><span class="p">(</span><span class="s2">&quot;myChain.pic&quot;</span><span class="p">,</span> <span class="n">defaults</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="accessing-the-all-atom-atomarray">
<h4>Accessing the all-atom AtomArray<a class="headerlink" href="#accessing-the-all-atom-atomarray" title="Permalink to this headline"></a></h4>
<p>All 3D XYZ coordinates in Biopython <code class="docutils literal notranslate"><span class="pre">Atom</span></code> objects are moved to a
single large array in the <code class="docutils literal notranslate"><span class="pre">Chain</span></code> class and replaced by Numpy ‘views’
into this array in an early step of
<code class="docutils literal notranslate"><span class="pre">atom_to_internal_coordinates</span></code>:math:<code class="docutils literal notranslate"><span class="pre">.</span> <span class="pre">Software</span> <span class="pre">accessing</span> <span class="pre">Biopython</span>
<span class="pre">``Atom</span></code> coordinates is not affected, but the new array may offer
efficiencies for future work.</p>
<p>Unlike the <code class="docutils literal notranslate"><span class="pre">Atom</span></code> XYZ coordinates, <code class="docutils literal notranslate"><span class="pre">AtomArray</span></code> coordinates are
homogeneous, meaning they are arrays like <code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">x</span> <span class="pre">y</span> <span class="pre">z</span> <span class="pre">1.0]</span></code> with 1.0 as
the fourth element. This facilitates efficient transformation using
combined translation and rotation matrices throughout the
<code class="docutils literal notranslate"><span class="pre">internal_coords</span></code> module. There is a corresponding <code class="docutils literal notranslate"><span class="pre">AtomArrayIndex</span></code>
dictionary, mapping <code class="docutils literal notranslate"><span class="pre">AtomKeys</span></code> to their coordinates.</p>
<p>Here we demonstrate reading coordinates for a specific C<span class="math notranslate nohighlight">\(\beta\)</span>
atom from the array, then show that modifying the array value modifies
the <code class="docutils literal notranslate"><span class="pre">Atom</span></code> object at the same time:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># access the array of all atoms for the chain, e.g. r2 above is residue 152 C-beta</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r2_cBeta_index</span> <span class="o">=</span> <span class="n">myChain</span><span class="o">.</span><span class="n">internal_coord</span><span class="o">.</span><span class="n">atomArrayIndex</span><span class="p">[</span><span class="n">AtomKey</span><span class="p">(</span><span class="s2">&quot;152_D_CB&quot;</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r2_cBeta_coords</span> <span class="o">=</span> <span class="n">myChain</span><span class="o">.</span><span class="n">internal_coord</span><span class="o">.</span><span class="n">atomArray</span><span class="p">[</span><span class="n">r2_cBeta_index</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">r2_cBeta_coords</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">[-0.75 -1.18 -0.51  1.  ]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># the Biopython Atom coord array is now a view into atomArray, so</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">r2_cBeta_coords</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">r2</span><span class="p">[</span><span class="s2">&quot;CB&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r2_cBeta_coords</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">1.0</span>  <span class="c1"># change the Y coord 1 angstrom</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">r2_cBeta_coords</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">r2</span><span class="p">[</span><span class="s2">&quot;CB&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># they are always the same (they share the same memory)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r2_cBeta_coords</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="mf">1.0</span>  <span class="c1"># restore</span>
</pre></div>
</div>
<p>Note that it is easy to ‘break’ the view linkage between the Atom coord
arrays and the chain atomArray. When modifying Atom coordinates
directly, use syntax for an element-by-element copy to avoid this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># use these:</span>
<span class="n">myAtom1</span><span class="o">.</span><span class="n">coord</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">myAtom2</span><span class="o">.</span><span class="n">coord</span>
<span class="n">myAtom1</span><span class="o">.</span><span class="n">coord</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">myAtom2</span><span class="o">.</span><span class="n">coord</span>
<span class="n">myAtom1</span><span class="o">.</span><span class="n">coord</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
    <span class="n">myAtom1</span><span class="o">.</span><span class="n">coord</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">myAtom2</span><span class="o">.</span><span class="n">coord</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

<span class="c1"># do not use:</span>
<span class="n">myAtom1</span><span class="o">.</span><span class="n">coord</span> <span class="o">=</span> <span class="n">myAtom2</span><span class="o">.</span><span class="n">coord</span>
<span class="n">myAtom1</span><span class="o">.</span><span class="n">coord</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
<p>Using the <code class="docutils literal notranslate"><span class="pre">atomArrayIndex</span></code> and knowledge of the <code class="docutils literal notranslate"><span class="pre">AtomKey</span></code> class
enables us to create Numpy ‘selectors’, as shown below to extract an
array of only the C<span class="math notranslate nohighlight">\(\alpha\)</span> atom coordinates:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># create a selector to filter just the C-alpha atoms from the all atom array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atmNameNdx</span> <span class="o">=</span> <span class="n">AtomKey</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">atm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aaI</span> <span class="o">=</span> <span class="n">myChain</span><span class="o">.</span><span class="n">internal_coord</span><span class="o">.</span><span class="n">atomArrayIndex</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">CaSelect</span> <span class="o">=</span> <span class="p">[</span><span class="n">aaI</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">aaI</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">akl</span><span class="p">[</span><span class="n">atmNameNdx</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;CA&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># now the ordered array of C-alpha atom coordinates is:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">CA_coords</span> <span class="o">=</span> <span class="n">myChain</span><span class="o">.</span><span class="n">internal_coord</span><span class="o">.</span><span class="n">atomArray</span><span class="p">[</span><span class="n">CaSelect</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># note this uses Numpy fancy indexing, so CA_coords is a new copy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># (if you modify it, the original atomArray is unaffected)</span>
</pre></div>
</div>
</section>
<section id="distance-plots">
<h4>Distance Plots<a class="headerlink" href="#distance-plots" title="Permalink to this headline"></a></h4>
<p>A benefit of the <code class="docutils literal notranslate"><span class="pre">atomArray</span></code> is that generating a distance plot from
it is a single line of <code class="docutils literal notranslate"><span class="pre">Numpy</span></code> code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">atomArray</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">atomArray</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Despite its briefness, the idiom cam be difficult to remember and in the
form above generates all-atom distances rather than the classic
C<span class="math notranslate nohighlight">\(\alpha\)</span> plot as may be desired. The
<code class="docutils literal notranslate"><span class="pre">distance_plot</span></code>:math:`` method wraps the line above and accepts an
optional selector like <code class="docutils literal notranslate"><span class="pre">CaSelect</span></code> defined in the previous section. See
<a class="reference internal" href="#fig-distanceplot"><span class="std std-numref">Fig. 4</span></a>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># create a C-alpha distance plot</span>
<span class="n">caDistances</span> <span class="o">=</span> <span class="n">myChain</span><span class="o">.</span><span class="n">internal_coord</span><span class="o">.</span><span class="n">distance_plot</span><span class="p">(</span><span class="n">CaSelect</span><span class="p">)</span>
<span class="c1"># display with e.g. MatPlotLib:</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">caDistances</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;hot&quot;</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<figure class="align-default" id="fig-distanceplot">
<a class="reference internal image-reference" href="../_images/1a8o-ca-plot.png"><img alt="C-alpha distance plot for PDB file 1A8O" src="../_images/1a8o-ca-plot.png" style="width: 30.0%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 4 </span><span class="caption-text">C-alpha distance plot for PDB file 1A8O (HIV capsid C-terminal domain)</span><a class="headerlink" href="#fig-distanceplot" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="building-a-structure-from-a-distance-plot">
<h4>Building a structure from a distance plot<a class="headerlink" href="#building-a-structure-from-a-distance-plot" title="Permalink to this headline"></a></h4>
<p>The all-atom distance plot is another representation of a protein
structure, also invariant to translation and rotation but lacking in
chirality information (a mirror-image structure will generate the same
distance plot). By combining the distance matrix with the signs of each
dihedral angle, it is possible to regenerate the internal coordinates.</p>
<p>This work uses equations developed by Blue, the Hedronometer, discussed
in <a class="reference external" href="https://math.stackexchange.com/a/49340/409">https://math.stackexchange.com/a/49340/409</a> and further in
<a class="reference external" href="http://daylateanddollarshort.com/mathdocs/Heron-like-Results-for-Tetrahedral-Volume.pdf">http://daylateanddollarshort.com/mathdocs/Heron-like-Results-for-Tetrahedral-Volume.pdf</a>.</p>
<p>To begin, we extract the distances and chirality values from ‘myChain’:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1">## create the all-atom distance plot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">distances</span> <span class="o">=</span> <span class="n">myCic</span><span class="o">.</span><span class="n">distance_plot</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">## get the signs of the dihedral angles</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chirality</span> <span class="o">=</span> <span class="n">myCic</span><span class="o">.</span><span class="n">dihedral_signs</span><span class="p">()</span>
</pre></div>
</div>
<p>We need a valid data structure matching ‘myChain’ to correctly rebuild
it; using <code class="docutils literal notranslate"><span class="pre">read_PIC_seq</span></code>:math:`` above would work in the general
case, but the 1A8O example used here has some ALTLOC complexity which
the sequence alone would not generate. For demonstration the easiest
approach is to simply duplicate the ‘myChain’ structure, but we set all
the atom and internal coordinate chain arrays to 0s (only for
demonstration) just to be certain there is no data coming through from
the original structure:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1">## get new, empty data structure : copy data structure from myChain</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">myChain2</span> <span class="o">=</span> <span class="n">IC_duplicate</span><span class="p">(</span><span class="n">myChain</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;A&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cic2</span> <span class="o">=</span> <span class="n">myChain2</span><span class="o">.</span><span class="n">internal_coord</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1">## clear the new atomArray and di/hedra value arrays, just for proof</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cic2</span><span class="o">.</span><span class="n">atomArray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">cic2</span><span class="o">.</span><span class="n">AAsiz</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cic2</span><span class="o">.</span><span class="n">dihedraAngle</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cic2</span><span class="o">.</span><span class="n">hedraAngle</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cic2</span><span class="o">.</span><span class="n">hedraL12</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cic2</span><span class="o">.</span><span class="n">hedraL23</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.0</span>
</pre></div>
</div>
<p>The approach is to regenerate the internal coordinates from the distance
plot data, then generate the atom coordinates from the internal
coordinates as shown above. To place the final generated structure in
the same coordinate space as the starting structure, we copy just the
coordinates for the first three N-C<span class="math notranslate nohighlight">\(\alpha\)</span>-C atoms from the
chain start of ‘myChain’ to the ‘myChain2’ structure (this is only
needed to demonstrate equivalence at end):</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1">## copy just the first N-Ca-C coords so structures will superimpose:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cic2</span><span class="o">.</span><span class="n">copy_initNCaCs</span><span class="p">(</span><span class="n">myChain</span><span class="o">.</span><span class="n">internal_coord</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">distance_to_internal_coordinates</span></code>:math:`` routine needs arrays
of the six inter-atom distances for each dihedron for the target
structure. The convenience routine <code class="docutils literal notranslate"><span class="pre">distplot_to_dh_arrays</span></code>:math:``
extracts these values from the previously generated distance matrix as
needed, and may be replaced by a user method to write these data to the
arrays in the <code class="docutils literal notranslate"><span class="pre">Chain.internal_coords</span></code> object.</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1">## copy distances to chain arrays:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cic2</span><span class="o">.</span><span class="n">distplot_to_dh_arrays</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span> <span class="n">chirality</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">## compute angles and dihedral angles from distances:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cic2</span><span class="o">.</span><span class="n">distance_to_internal_coordinates</span><span class="p">()</span>
</pre></div>
</div>
<p>The steps below generate the atom coordinates from the newly generated
‘myChain2’ internal coordinates, then use the Numpy
<code class="docutils literal notranslate"><span class="pre">allclose</span></code>:math:`` routine to confirm that all values match to
better than PDB file resolution:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1">## generate XYZ coordinates from internal coordinates:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">myChain2</span><span class="o">.</span><span class="n">internal_to_atom_coordinates</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">## confirm result atomArray matches original structure:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">cic2</span><span class="o">.</span><span class="n">atomArray</span><span class="p">,</span> <span class="n">myCic</span><span class="o">.</span><span class="n">atomArray</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Note that this procedure does not use the entire distance matrix, but
only the six local distances between the four atoms of each dihedral
angle.</p>
</section>
<section id="superimposing-residues-and-their-neighborhoods">
<h4>Superimposing residues and their neighborhoods<a class="headerlink" href="#superimposing-residues-and-their-neighborhoods" title="Permalink to this headline"></a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">internal_coords</span></code> module relies on transforming atom coordinates
between different coordinate spaces for both calculation of torsion
angles and reconstruction of structures. Each dihedron has a coordinate
space transform placing its first atom on the XZ plane, second atom at
the origin, and third atom on the +Z axis, as well as a corresponding
reverse transform which will return it to the coordinates in the
original structure. These transform matrices are available to use as
shown below. By judicious choice of a reference dihedron, pairwise and
higher order residue intereactions can be investigated and visualized
across multiple protein structures, e.g. <a class="reference internal" href="#fig-phepairs"><span class="std std-numref">Fig. 5</span></a>.</p>
<figure class="align-default" id="fig-phepairs">
<a class="reference internal image-reference" href="../_images/phe-pairs-3pbl.png"><img alt="Neighboring phenylalanine sidechains in PDB file 3PBL" src="../_images/phe-pairs-3pbl.png" style="width: 70.0%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 5 </span><span class="caption-text">Neighboring phenylalanine sidechains in PDB file 3PBL (human dopamine D3 receptor)</span><a class="headerlink" href="#fig-phepairs" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>This example superimposes each PHE residue in a chain on its
N-C<span class="math notranslate nohighlight">\(\alpha\)</span>-C<span class="math notranslate nohighlight">\(\beta\)</span> atoms, and presents all PHEs in the
chain in the respective coordinate space as a simple demonstration. A
more realistic exploration of pairwise sidechain interactions would
examine a dataset of structures and filter for interaction classes as
discussed in the relevant literature.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># superimpose all phe-phe pairs - quick hack just to demonstrate concept</span>
<span class="c1"># for analyzing pairwise residue interactions.  Generates PDB ATOM records</span>
<span class="c1"># placing each PHE at origin and showing all other PHEs in environment</span>

<span class="c1">## shorthand for key variables:</span>
<span class="n">cic</span> <span class="o">=</span> <span class="n">myChain</span><span class="o">.</span><span class="n">internal_coord</span>
<span class="n">resNameNdx</span> <span class="o">=</span> <span class="n">AtomKey</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">resname</span>
<span class="n">aaNdx</span> <span class="o">=</span> <span class="n">cic</span><span class="o">.</span><span class="n">atomArrayIndex</span>

<span class="c1">## select just PHE atoms:</span>
<span class="n">pheAtomSelect</span> <span class="o">=</span> <span class="p">[</span><span class="n">aaNdx</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">aaNdx</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">akl</span><span class="p">[</span><span class="n">resNameNdx</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;F&quot;</span><span class="p">]</span>
<span class="n">aaF</span> <span class="o">=</span> <span class="n">cic</span><span class="o">.</span><span class="n">atomArray</span><span class="p">[</span><span class="n">pheAtomSelect</span><span class="p">]</span>  <span class="c1"># numpy fancy indexing makes COPY not view</span>

<span class="k">for</span> <span class="n">ric</span> <span class="ow">in</span> <span class="n">cic</span><span class="o">.</span><span class="n">ordered_aa_ic_list</span><span class="p">:</span>  <span class="c1"># internal_coords version of get_residues()</span>
    <span class="k">if</span> <span class="n">ric</span><span class="o">.</span><span class="n">lc</span> <span class="o">==</span> <span class="s2">&quot;F&quot;</span><span class="p">:</span>  <span class="c1"># if PHE, get transform matrices for chi1 dihedral</span>
        <span class="n">chi1</span> <span class="o">=</span> <span class="n">ric</span><span class="o">.</span><span class="n">pick_angle</span><span class="p">(</span><span class="s2">&quot;chi1&quot;</span><span class="p">)</span>  <span class="c1"># N:CA:CB:CG space has C-alpha at origin</span>
        <span class="n">cst</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">chi1</span><span class="o">.</span><span class="n">cst</span><span class="p">)</span>  <span class="c1"># transform TO chi1 space</span>
        <span class="c1"># rcst = np.transpose(chi1.rcst)  # transform FROM chi1 space (not needed here)</span>
        <span class="n">cic</span><span class="o">.</span><span class="n">atomArray</span><span class="p">[</span><span class="n">pheAtomSelect</span><span class="p">]</span> <span class="o">=</span> <span class="n">aaF</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">cst</span><span class="p">)</span>  <span class="c1"># transform just the PHEs</span>
        <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">myChain</span><span class="o">.</span><span class="n">get_residues</span><span class="p">():</span>  <span class="c1"># print PHEs in new coordinate space</span>
            <span class="k">if</span> <span class="n">res</span><span class="o">.</span><span class="n">resname</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;PHE&quot;</span><span class="p">]:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">internal_coord</span><span class="o">.</span><span class="n">pdb_residue_string</span><span class="p">())</span>
        <span class="n">cic</span><span class="o">.</span><span class="n">atomArray</span><span class="p">[</span><span class="n">pheAtomSelect</span><span class="p">]</span> <span class="o">=</span> <span class="n">aaF</span>  <span class="c1"># restore coordinate space from copy</span>
</pre></div>
</div>
</section>
<section id="d-printing-protein-structures">
<h4>3D printing protein structures<a class="headerlink" href="#d-printing-protein-structures" title="Permalink to this headline"></a></h4>
<p>OpenSCAD (<a class="reference external" href="https://openscad.org">https://openscad.org</a>) is a language for creating solid 3D CAD
objects. The algorithm to construct a protein structure from internal
coordinates is supplied in OpenSCAD with data describing a structure,
such that a model can be generated suitable for 3D printing. While other
software can generate STL data as a rendering option for 3D printing
(e.g. Chimera, <a class="reference external" href="https://www.cgl.ucsf.edu/chimera/">https://www.cgl.ucsf.edu/chimera/</a>), this approach
generates spheres and cylinders as output and is therefore more amenable
to modifications relevant to 3D printing protein structures. Individual
residues and bonds can be selected in the OpenSCAD code for special
handling, such as highlighting by size or adding rotatable bonds in
specific positions (see <a class="reference external" href="https://www.thingiverse.com/thing:3957471">https://www.thingiverse.com/thing:3957471</a> for an
example).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># write OpenSCAD program of spheres and cylinders to 3d print myChain backbone</span>
<span class="c1">## set atom load filter to accept backbone only:</span>
<span class="n">IC_Residue</span><span class="o">.</span><span class="n">accept_atoms</span> <span class="o">=</span> <span class="n">IC_Residue</span><span class="o">.</span><span class="n">accept_backbone</span>
<span class="c1">## set chain break cutoff very high to bridge missing residues with long bonds</span>
<span class="n">IC_Chain</span><span class="o">.</span><span class="n">MaxPeptideBond</span> <span class="o">=</span> <span class="mf">4.0</span>
<span class="c1">## delete existing data to force re-read of all atoms with attributes set above:</span>
<span class="n">myChain</span><span class="o">.</span><span class="n">internal_coord</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">write_SCAD</span><span class="p">(</span><span class="n">myChain</span><span class="p">,</span> <span class="s2">&quot;myChain.scad&quot;</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">10.0</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="internal-coords-control-attributes">
<h4><code class="docutils literal notranslate"><span class="pre">internal_coords</span></code> control attributes<a class="headerlink" href="#internal-coords-control-attributes" title="Permalink to this headline"></a></h4>
<p>A few control attributes are available in the <code class="docutils literal notranslate"><span class="pre">internal_coords</span></code>
classes to modify or filter data as internal coordinates are calculated.
These are listed in Table <a class="reference internal" href="#table-ic-attribs"><span class="std std-ref">Control attributes in Bio.PDB.internal_coords.</span></a>:</p>
<table class="docutils align-default" id="table-ic-attribs">
<caption><span class="caption-number">Table 3 </span><span class="caption-text">Control attributes in Bio.PDB.internal_coords.</span><a class="headerlink" href="#table-ic-attribs" title="Permalink to this table"></a></caption>
<colgroup>
<col style="width: 19%" />
<col style="width: 27%" />
<col style="width: 27%" />
<col style="width: 28%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Class</p></th>
<th class="head"><p>Attribute</p></th>
<th class="head"><p>Default</p></th>
<th class="head"><p>Effect</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>AtomKey</p></td>
<td><p>d2h</p></td>
<td><p>False</p></td>
<td><p>Convert D atoms
to H if True</p></td>
</tr>
<tr class="row-odd"><td><p>IC_Chain</p></td>
<td><p>MaxPeptideBond</p></td>
<td><p>1.4</p></td>
<td><p>Max C-N length
w/o chain break;
make large to
link over
missing residues
for 3D models</p></td>
</tr>
<tr class="row-even"><td><p>IC_Residue</p></td>
<td><p>accept_atoms</p></td>
<td><p>mainchain,
hydrogen atoms</p></td>
<td><p>override to
remove some or
all sidechains,
H’s, D’s</p></td>
</tr>
<tr class="row-odd"><td><p>IC_Residue</p></td>
<td><p>accept_resnames</p></td>
<td><p>CYG, YCM, UNK</p></td>
<td><p>3-letter names
for HETATMs to
process,
backbone only
unless added to
ic_data.py</p></td>
</tr>
<tr class="row-even"><td><p>IC_Residue</p></td>
<td><p>gly_Cbeta</p></td>
<td><p>False</p></td>
<td><p>override to
generate Gly
C<span class="math notranslate nohighlight">\(\beta\)</span>
atoms based on
database
averages</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="determining-atom-atom-contacts">
<h3>Determining atom-atom contacts<a class="headerlink" href="#determining-atom-atom-contacts" title="Permalink to this headline"></a></h3>
<p>Use <code class="docutils literal notranslate"><span class="pre">NeighborSearch</span></code> to perform neighbor lookup. The neighbor lookup
is done using a KD tree module written in C (see the <code class="docutils literal notranslate"><span class="pre">KDTree</span></code> class in
module <code class="docutils literal notranslate"><span class="pre">Bio.PDB.kdtrees</span></code>), making it very fast. It also includes a
fast method to find all point pairs within a certain distance of each
other.</p>
</section>
<section id="superimposing-two-structures">
<h3>Superimposing two structures<a class="headerlink" href="#superimposing-two-structures" title="Permalink to this headline"></a></h3>
<p>Use a <code class="docutils literal notranslate"><span class="pre">Superimposer</span></code> object to superimpose two coordinate sets. This
object calculates the rotation and translation matrix that rotates two
lists of atoms on top of each other in such a way that their RMSD is
minimized. Of course, the two lists need to contain the same number of
atoms. The <code class="docutils literal notranslate"><span class="pre">Superimposer</span></code> object can also apply the
rotation/translation to a list of atoms. The rotation and translation
are stored as a tuple in the <code class="docutils literal notranslate"><span class="pre">rotran</span></code> attribute of the
<code class="docutils literal notranslate"><span class="pre">Superimposer</span></code> object (note that the rotation is right multiplying!).
The RMSD is stored in the <code class="docutils literal notranslate"><span class="pre">rmsd</span></code> attribute.</p>
<p>The algorithm used by <code class="docutils literal notranslate"><span class="pre">Superimposer</span></code> comes from
Golub &amp; Van Loan <a class="reference internal" href="chapter_bibliography.html#golub1989" id="id1"><span>[Golub1989]</span></a> and makes use of
singular value decomposition (this is implemented in the general
<code class="docutils literal notranslate"><span class="pre">Bio.SVDSuperimposer</span></code> module).</p>
<p>Example:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sup</span> <span class="o">=</span> <span class="n">Superimposer</span><span class="p">()</span>
<span class="go"># Specify the atom lists</span>
<span class="go"># &#39;fixed&#39; and &#39;moving&#39; are lists of Atom objects</span>
<span class="go"># The moving atoms will be put on the fixed atoms</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sup</span><span class="o">.</span><span class="n">set_atoms</span><span class="p">(</span><span class="n">fixed</span><span class="p">,</span> <span class="n">moving</span><span class="p">)</span>
<span class="go"># Print rotation/translation/rmsd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sup</span><span class="o">.</span><span class="n">rotran</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sup</span><span class="o">.</span><span class="n">rms</span><span class="p">)</span>
<span class="go"># Apply rotation/translation to the moving atoms</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sup</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">moving</span><span class="p">)</span>
</pre></div>
</div>
<p>To superimpose two structures based on their active sites, use the
active site atoms to calculate the rotation/translation matrices (as
above), and apply these to the whole molecule.</p>
</section>
<section id="mapping-the-residues-of-two-related-structures-onto-each-other">
<h3>Mapping the residues of two related structures onto each other<a class="headerlink" href="#mapping-the-residues-of-two-related-structures-onto-each-other" title="Permalink to this headline"></a></h3>
<p>First, create an alignment file in FASTA format, then use the
<code class="docutils literal notranslate"><span class="pre">StructureAlignment</span></code> class. This class can also be used for alignments
with more than two structures.</p>
</section>
<section id="calculating-the-half-sphere-exposure">
<h3>Calculating the Half Sphere Exposure<a class="headerlink" href="#calculating-the-half-sphere-exposure" title="Permalink to this headline"></a></h3>
<p>Half Sphere Exposure (HSE) is a new, 2D measure of solvent exposure
<a class="reference internal" href="chapter_bibliography.html#hamelryck2005" id="id2"><span>[Hamelryck2005]</span></a>. Basically, it counts the number of
C<span class="math notranslate nohighlight">\(\alpha\)</span> atoms around a residue in the direction of its side
chain, and in the opposite direction (within a radius of 13 Å. Despite
its simplicity, it outperforms many other measures of solvent exposure.</p>
<p>HSE comes in two flavors: HSE<span class="math notranslate nohighlight">\(\alpha\)</span> and HSE<span class="math notranslate nohighlight">\(\beta\)</span>.
The former only uses the C<span class="math notranslate nohighlight">\(\alpha\)</span> atom positions, while the
latter uses the C<span class="math notranslate nohighlight">\(\alpha\)</span> and C<span class="math notranslate nohighlight">\(\beta\)</span> atom positions.
The HSE measure is calculated by the <code class="docutils literal notranslate"><span class="pre">HSExposure</span></code> class, which can
also calculate the contact number. The latter class has methods which
return dictionaries that map a <code class="docutils literal notranslate"><span class="pre">Residue</span></code> object to its corresponding
HSE<span class="math notranslate nohighlight">\(\alpha\)</span>, HSE<span class="math notranslate nohighlight">\(\beta\)</span> and contact number values.</p>
<p>Example:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">structure</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hse</span> <span class="o">=</span> <span class="n">HSExposure</span><span class="p">()</span>
<span class="go"># Calculate HSEalpha</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exp_ca</span> <span class="o">=</span> <span class="n">hse</span><span class="o">.</span><span class="n">calc_hs_exposure</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">option</span><span class="o">=</span><span class="s2">&quot;CA3&quot;</span><span class="p">)</span>
<span class="go"># Calculate HSEbeta</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exp_cb</span> <span class="o">=</span> <span class="n">hse</span><span class="o">.</span><span class="n">calc_hs_exposure</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">option</span><span class="o">=</span><span class="s2">&quot;CB&quot;</span><span class="p">)</span>
<span class="go"># Calculate classical coordination number</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exp_fs</span> <span class="o">=</span> <span class="n">hse</span><span class="o">.</span><span class="n">calc_fs_exposure</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
<span class="go"># Print HSEalpha for a residue</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">exp_ca</span><span class="p">[</span><span class="n">some_residue</span><span class="p">])</span>
</pre></div>
</div>
</section>
<section id="determining-the-secondary-structure">
<h3>Determining the secondary structure<a class="headerlink" href="#determining-the-secondary-structure" title="Permalink to this headline"></a></h3>
<p>For this functionality, you need to install DSSP (and obtain a license
for it — free for academic use, see
<a class="reference external" href="https://swift.cmbi.umcn.nl/gv/dssp/">https://swift.cmbi.umcn.nl/gv/dssp/</a>). Then use the <code class="docutils literal notranslate"><span class="pre">DSSP</span></code> class, which
maps <code class="docutils literal notranslate"><span class="pre">Residue</span></code> objects to their secondary structure (and accessible
surface area). The DSSP codes are listed in
Table <a class="reference internal" href="#table-dssp-codes"><span class="std std-ref">DSSP codes in Bio.PDB.</span></a>. Note that DSSP (the program, and thus
by consequence the class) cannot handle multiple models!</p>
<table class="docutils align-default" id="table-dssp-codes">
<caption><span class="caption-number">Table 4 </span><span class="caption-text">DSSP codes in Bio.PDB.</span><a class="headerlink" href="#table-dssp-codes" title="Permalink to this table"></a></caption>
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Code</p></th>
<th class="head"><p>Secondary structure</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>H</p></td>
<td><p><span class="math notranslate nohighlight">\(\alpha\)</span>-helix</p></td>
</tr>
<tr class="row-odd"><td><p>B</p></td>
<td><p>Isolated <span class="math notranslate nohighlight">\(\beta\)</span>-bridge residue</p></td>
</tr>
<tr class="row-even"><td><p>E</p></td>
<td><p>Strand</p></td>
</tr>
<tr class="row-odd"><td><p>G</p></td>
<td><p>3-10 helix</p></td>
</tr>
<tr class="row-even"><td><p>I</p></td>
<td><p><span class="math notranslate nohighlight">\(\Pi\)</span>-helix</p></td>
</tr>
<tr class="row-odd"><td><p>T</p></td>
<td><p>Turn</p></td>
</tr>
<tr class="row-even"><td><p>S</p></td>
<td><p>Bend</p></td>
</tr>
<tr class="row-odd"><td><ul class="simple">
<li></li>
</ul>
</td>
<td><p>Other</p></td>
</tr>
</tbody>
</table>
<p>The <code class="docutils literal notranslate"><span class="pre">DSSP</span></code> class can also be used to calculate the accessible surface
area of a residue. But see also section <a class="reference internal" href="#sec-residue-depth"><span class="std std-ref">Calculating the residue depth</span></a>.</p>
</section>
<section id="calculating-the-residue-depth">
<span id="sec-residue-depth"></span><h3>Calculating the residue depth<a class="headerlink" href="#calculating-the-residue-depth" title="Permalink to this headline"></a></h3>
<p>Residue depth is the average distance of a residue’s atoms from the
solvent accessible surface. It’s a fairly new and very powerful
parameterization of solvent accessibility. For this functionality, you
need to install Michel Sanner’s MSMS program
(<a class="reference external" href="https://www.scripps.edu/sanner/html/msms_home.html">https://www.scripps.edu/sanner/html/msms_home.html</a>). Then use the
<code class="docutils literal notranslate"><span class="pre">ResidueDepth</span></code> class. This class behaves as a dictionary which maps
<code class="docutils literal notranslate"><span class="pre">Residue</span></code> objects to corresponding (residue depth, C<span class="math notranslate nohighlight">\(\alpha\)</span>
depth) tuples. The C<span class="math notranslate nohighlight">\(\alpha\)</span> depth is the distance of a
residue’s C<span class="math notranslate nohighlight">\(\alpha\)</span> atom to the solvent accessible surface.</p>
<p>Example:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">structure</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rd</span> <span class="o">=</span> <span class="n">ResidueDepth</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">pdb_file</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">residue_depth</span><span class="p">,</span> <span class="n">ca_depth</span> <span class="o">=</span> <span class="n">rd</span><span class="p">[</span><span class="n">some_residue</span><span class="p">]</span>
</pre></div>
</div>
<p>You can also get access to the molecular surface itself (via the
<code class="docutils literal notranslate"><span class="pre">get_surface</span></code> function), in the form of a Numeric Python array with
the surface points.</p>
</section>
</section>
<section id="common-problems-in-pdb-files">
<h2>Common problems in PDB files<a class="headerlink" href="#common-problems-in-pdb-files" title="Permalink to this headline"></a></h2>
<p>It is well known that many PDB files contain semantic errors (not the
structures themselves, but their representation in PDB files). Bio.PDB
tries to handle this in two ways. The PDBParser object can behave in two
ways: a restrictive way and a permissive way, which is the default.</p>
<p>Example:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="go"># Permissive parser</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">PDBParser</span><span class="p">(</span><span class="n">PERMISSIVE</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">PDBParser</span><span class="p">()</span>  <span class="c1"># The same (default)</span>
<span class="go"># Strict parser</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strict_parser</span> <span class="o">=</span> <span class="n">PDBParser</span><span class="p">(</span><span class="n">PERMISSIVE</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>In the permissive state (DEFAULT), PDB files that obviously contain
errors are “corrected” (i.e. some residues or atoms are left out). These
errors include:</p>
<ul class="simple">
<li><p>Multiple residues with the same identifier</p></li>
<li><p>Multiple atoms with the same identifier (taking into account the
altloc identifier)</p></li>
</ul>
<p>These errors indicate real problems in the PDB file (for details see Hamelryck and Manderick, 2003 <a class="reference internal" href="chapter_bibliography.html#hamelryck2003a" id="id3"><span>[Hamelryck2003A]</span></a>). In
the restrictive state, PDB files with errors cause an exception to
occur. This is useful to find errors in PDB files.</p>
<p>Some errors however are automatically corrected. Normally each
disordered atom should have a non-blank altloc identifier. However,
there are many structures that do not follow this convention, and have a
blank and a non-blank identifier for two disordered positions of the
same atom. This is automatically interpreted in the right way.</p>
<p>Sometimes a structure contains a list of residues belonging to chain A,
followed by residues belonging to chain B, and again followed by
residues belonging to chain A, i.e. the chains are ’broken’. This is
also correctly interpreted.</p>
<section id="examples">
<span id="sec-problem-structures"></span><h3>Examples<a class="headerlink" href="#examples" title="Permalink to this headline"></a></h3>
<p>The PDBParser/Structure class was tested on about 800 structures (each
belonging to a unique SCOP superfamily). This takes about 20 minutes, or
on average 1.5 seconds per structure. Parsing the structure of the large
ribosomal subunit (1FKK), which contains about 64000 atoms, takes 10
seconds on a 1000 MHz PC.</p>
<p>Three exceptions were generated in cases where an unambiguous data
structure could not be built. In all three cases, the likely cause is an
error in the PDB file that should be corrected. Generating an exception
in these cases is much better than running the chance of incorrectly
describing the structure in a data structure.</p>
<section id="duplicate-residues">
<h4>Duplicate residues<a class="headerlink" href="#duplicate-residues" title="Permalink to this headline"></a></h4>
<p>One structure contains two amino acid residues in one chain with the
same sequence identifier (resseq 3) and icode. Upon inspection it was
found that this chain contains the residues Thr A3, …, Gly A202, Leu A3,
Glu A204. Clearly, Leu A3 should be Leu A203. A couple of similar
situations exist for structure 1FFK (which e.g. contains Gly B64, Met
B65, Glu B65, Thr B67, i.e. residue Glu B65 should be Glu B66).</p>
</section>
<section id="duplicate-atoms">
<h4>Duplicate atoms<a class="headerlink" href="#duplicate-atoms" title="Permalink to this headline"></a></h4>
<p>Structure 1EJG contains a Ser/Pro point mutation in chain A at position
22. In turn, Ser 22 contains some disordered atoms. As expected, all
atoms belonging to Ser 22 have a non-blank altloc specifier (B or C).
All atoms of Pro 22 have altloc A, except the N atom which has a blank
altloc. This generates an exception, because all atoms belonging to two
residues at a point mutation should have non-blank altloc. It turns out
that this atom is probably shared by Ser and Pro 22, as Ser 22 misses
the N atom. Again, this points to a problem in the file: the N atom
should be present in both the Ser and the Pro residue, in both cases
associated with a suitable altloc identifier.</p>
</section>
</section>
<section id="automatic-correction">
<h3>Automatic correction<a class="headerlink" href="#automatic-correction" title="Permalink to this headline"></a></h3>
<p>Some errors are quite common and can be easily corrected without much
risk of making a wrong interpretation. These cases are listed below.</p>
<section id="a-blank-altloc-for-a-disordered-atom">
<h4>A blank altloc for a disordered atom<a class="headerlink" href="#a-blank-altloc-for-a-disordered-atom" title="Permalink to this headline"></a></h4>
<p>Normally each disordered atom should have a non-blank altloc identifier.
However, there are many structures that do not follow this convention,
and have a blank and a non-blank identifier for two disordered positions
of the same atom. This is automatically interpreted in the right way.</p>
</section>
<section id="broken-chains">
<h4>Broken chains<a class="headerlink" href="#broken-chains" title="Permalink to this headline"></a></h4>
<p>Sometimes a structure contains a list of residues belonging to chain A,
followed by residues belonging to chain B, and again followed by
residues belonging to chain A, i.e. the chains are “broken”. This is
correctly interpreted.</p>
</section>
</section>
<section id="fatal-errors">
<h3>Fatal errors<a class="headerlink" href="#fatal-errors" title="Permalink to this headline"></a></h3>
<p>Sometimes a PDB file cannot be unambiguously interpreted. Rather than
guessing and risking a mistake, an exception is generated, and the user
is expected to correct the PDB file. These cases are listed below.</p>
<section id="duplicate-residues-1">
<span id="id4"></span><h4>Duplicate residues<a class="headerlink" href="#duplicate-residues-1" title="Permalink to this headline"></a></h4>
<p>All residues in a chain should have a unique id. This id is generated
based on:</p>
<ul class="simple">
<li><p>The sequence identifier (resseq).</p></li>
<li><p>The insertion code (icode).</p></li>
<li><p>The hetfield string (“W” for waters and “H_” followed by the residue
name for other hetero residues)</p></li>
<li><p>The residue names of the residues in the case of point mutations (to
store the Residue objects in a DisorderedResidue object).</p></li>
</ul>
<p>If this does not lead to a unique id something is quite likely wrong,
and an exception is generated.</p>
</section>
<section id="duplicate-atoms-1">
<span id="id5"></span><h4>Duplicate atoms<a class="headerlink" href="#duplicate-atoms-1" title="Permalink to this headline"></a></h4>
<p>All atoms in a residue should have a unique id. This id is generated
based on:</p>
<ul class="simple">
<li><p>The atom name (without spaces, or with spaces if a problem arises).</p></li>
<li><p>The altloc specifier.</p></li>
</ul>
<p>If this does not lead to a unique id something is quite likely wrong,
and an exception is generated.</p>
</section>
</section>
</section>
<section id="accessing-the-protein-data-bank">
<h2>Accessing the Protein Data Bank<a class="headerlink" href="#accessing-the-protein-data-bank" title="Permalink to this headline"></a></h2>
<section id="downloading-structures-from-the-protein-data-bank">
<h3>Downloading structures from the Protein Data Bank<a class="headerlink" href="#downloading-structures-from-the-protein-data-bank" title="Permalink to this headline"></a></h3>
<p>Structures can be downloaded from the PDB (Protein Data Bank) by using
the <code class="docutils literal notranslate"><span class="pre">retrieve_pdb_file</span></code> method on a <code class="docutils literal notranslate"><span class="pre">PDBList</span></code> object. The argument
for this method is the PDB identifier of the structure.</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pdbl</span> <span class="o">=</span> <span class="n">PDBList</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pdbl</span><span class="o">.</span><span class="n">retrieve_pdb_file</span><span class="p">(</span><span class="s2">&quot;1FAT&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">PDBList</span></code> class can also be used as a command-line tool:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="go">python PDBList.py 1fat</span>
</pre></div>
</div>
<p>The downloaded file will be called <code class="docutils literal notranslate"><span class="pre">pdb1fat.ent</span></code> and stored in the
current working directory. Note that the <code class="docutils literal notranslate"><span class="pre">retrieve_pdb_file</span></code> method
also has an optional argument <code class="docutils literal notranslate"><span class="pre">pdir</span></code> that specifies a specific
directory in which to store the downloaded PDB files.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">retrieve_pdb_file</span></code> method also has some options to specify the
compression format used for the download, and the program used for local
decompression (default <code class="docutils literal notranslate"><span class="pre">.Z</span></code> format and <code class="docutils literal notranslate"><span class="pre">gunzip</span></code>). In addition, the
PDB ftp site can be specified upon creation of the <code class="docutils literal notranslate"><span class="pre">PDBList</span></code> object.
By default, the server of the Worldwide Protein Data Bank
(<a class="reference external" href="ftp://ftp.wwpdb.org/pub/pdb/data/structures/divided/pdb/">ftp://ftp.wwpdb.org/pub/pdb/data/structures/divided/pdb/</a>) is used. See
the API documentation for more details. Thanks again to Kristian Rother
for donating this module.</p>
</section>
<section id="downloading-the-entire-pdb">
<h3>Downloading the entire PDB<a class="headerlink" href="#downloading-the-entire-pdb" title="Permalink to this headline"></a></h3>
<p>The following commands will store all PDB files in the <code class="docutils literal notranslate"><span class="pre">/data/pdb</span></code>
directory:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="go">python PDBList.py all /data/pdb</span>

<span class="go">python PDBList.py all /data/pdb -d</span>
</pre></div>
</div>
<p>The API method for this is called <code class="docutils literal notranslate"><span class="pre">download_entire_pdb</span></code>. Adding the
<code class="docutils literal notranslate"><span class="pre">-d</span></code> option will store all files in the same directory. Otherwise,
they are sorted into PDB-style subdirectories according to their PDB
ID’s. Depending on the traffic, a complete download will take 2-4 days.</p>
</section>
<section id="keeping-a-local-copy-of-the-pdb-up-to-date">
<h3>Keeping a local copy of the PDB up to date<a class="headerlink" href="#keeping-a-local-copy-of-the-pdb-up-to-date" title="Permalink to this headline"></a></h3>
<p>This can also be done using the <code class="docutils literal notranslate"><span class="pre">PDBList</span></code> object. One simply creates a
<code class="docutils literal notranslate"><span class="pre">PDBList</span></code> object (specifying the directory where the local copy of the
PDB is present) and calls the <code class="docutils literal notranslate"><span class="pre">update_pdb</span></code> method:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pl</span> <span class="o">=</span> <span class="n">PDBList</span><span class="p">(</span><span class="n">pdb</span><span class="o">=</span><span class="s2">&quot;/data/pdb&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pl</span><span class="o">.</span><span class="n">update_pdb</span><span class="p">()</span>
</pre></div>
</div>
<p>One can of course make a weekly <code class="docutils literal notranslate"><span class="pre">cronjob</span></code> out of this to keep the
local copy automatically up-to-date. The PDB ftp site can also be
specified (see API documentation).</p>
<p><code class="docutils literal notranslate"><span class="pre">PDBList</span></code> has some additional methods that can be of use. The
<code class="docutils literal notranslate"><span class="pre">get_all_obsolete</span></code> method can be used to get a list of all obsolete
PDB entries. The <code class="docutils literal notranslate"><span class="pre">changed_this_week</span></code> method can be used to obtain the
entries that were added, modified or obsoleted during the current week.
For more info on the possibilities of <code class="docutils literal notranslate"><span class="pre">PDBList</span></code>, see the API
documentation.</p>
</section>
</section>
<section id="general-questions">
<h2>General questions<a class="headerlink" href="#general-questions" title="Permalink to this headline"></a></h2>
<section id="how-well-tested-is-bio-pdb">
<h3>How well tested is Bio.PDB?<a class="headerlink" href="#how-well-tested-is-bio-pdb" title="Permalink to this headline"></a></h3>
<p>Pretty well, actually. Bio.PDB has been extensively tested on nearly
5500 structures from the PDB - all structures seemed to be parsed
correctly. More details can be found in the Bio.PDB Bioinformatics
article. Bio.PDB has been used/is being used in many research projects
as a reliable tool. In fact, I’m using Bio.PDB almost daily for research
purposes and continue working on improving it and adding new features.</p>
</section>
<section id="how-fast-is-it">
<h3>How fast is it?<a class="headerlink" href="#how-fast-is-it" title="Permalink to this headline"></a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">PDBParser</span></code> performance was tested on about 800 structures (each
belonging to a unique SCOP superfamily). This takes about 20 minutes, or
on average 1.5 seconds per structure. Parsing the structure of the large
ribosomal subunit (1FKK), which contains about 64000 atoms, takes 10
seconds on a 1000 MHz PC. In short: it’s more than fast enough for many
applications.</p>
</section>
<section id="is-there-support-for-molecular-graphics">
<h3>Is there support for molecular graphics?<a class="headerlink" href="#is-there-support-for-molecular-graphics" title="Permalink to this headline"></a></h3>
<p>Not directly, mostly since there are quite a few Python based/Python
aware solutions already, that can potentially be used with Bio.PDB. My
choice is Pymol, BTW (I’ve used this successfully with Bio.PDB, and
there will probably be specific PyMol modules in Bio.PDB soon/some day).
Python based/aware molecular graphics solutions include:</p>
<ul class="simple">
<li><p>PyMol: <a class="reference external" href="https://pymol.org/">https://pymol.org/</a></p></li>
<li><p>Chimera: <a class="reference external" href="https://www.cgl.ucsf.edu/chimera/">https://www.cgl.ucsf.edu/chimera/</a></p></li>
<li><p>PMV: <a class="reference external" href="http://www.scripps.edu/~sanner/python/">http://www.scripps.edu/~sanner/python/</a></p></li>
<li><p>Coot: <a class="reference external" href="https://www2.mrc-lmb.cam.ac.uk/personal/pemsley/coot/">https://www2.mrc-lmb.cam.ac.uk/personal/pemsley/coot/</a></p></li>
<li><p>CCP4mg: <a class="reference external" href="http://www.ccp4.ac.uk/MG/">http://www.ccp4.ac.uk/MG/</a></p></li>
<li><p>mmLib: <a class="reference external" href="http://pymmlib.sourceforge.net/">http://pymmlib.sourceforge.net/</a></p></li>
<li><p>VMD: <a class="reference external" href="https://www.ks.uiuc.edu/Research/vmd/">https://www.ks.uiuc.edu/Research/vmd/</a></p></li>
<li><p>MMTK: <a class="reference external" href="http://dirac.cnrs-orleans.fr/MMTK/">http://dirac.cnrs-orleans.fr/MMTK/</a></p></li>
</ul>
</section>
<section id="whos-using-bio-pdb">
<h3>Who’s using Bio.PDB?<a class="headerlink" href="#whos-using-bio-pdb" title="Permalink to this headline"></a></h3>
<p>Bio.PDB was used in the construction of DISEMBL, a web server that
predicts disordered regions in proteins (<a class="reference external" href="http://dis.embl.de/">http://dis.embl.de/</a>). Bio.PDB
has also been used to perform a large scale search for active sites
similarities between protein structures in the PDB
<a class="reference internal" href="chapter_bibliography.html#hamelryck2003b" id="id6"><span>[Hamelryck2003B]</span></a>, and to develop a
new algorithm that identifies linear secondary structure elements <a class="reference internal" href="chapter_bibliography.html#majumdar2005" id="id7"><span>[Majumdar2005]</span></a>.</p>
<p>Judging from requests for features and information, Bio.PDB is also used
by several LPCs (Large Pharmaceutical Companies :-).</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="chapter_uniprot.html" class="btn btn-neutral float-left" title="Swiss-Prot and ExPASy" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="chapter_popgen.html" class="btn btn-neutral float-right" title="Bio.PopGen: Population genetics" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 1999-2024, The Biopython Contributors. See the Biopython license terms.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  


  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      Biopython v: 1.84.dev0
      <span class="fa fa-caret-down"></span>
    </span>
    <div class="rst-other-versions">
      <dl>
        <dt>Versions</dt>
        
          <dd><a href="/docs/1.83/">Previous</a></dd>
        
          <dd><a href="/docs/latest/">Latest</a></dd>
        
          <dd><a href="/docs/dev/">Develop</a></dd>
        
      </dl>
      <dl>
        <dt>Biopython Project</dt>
          <dd>
            <a href="https://biopython.org" class="icon icon-home">  Homepage</a>
          </dd>
          <dd>
            <a href="https://github.com/biopython/biopython" class="fa fa-github">  On GitHub</a>
          </dd>
      </dl>
    </div>
  </div>
<script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>